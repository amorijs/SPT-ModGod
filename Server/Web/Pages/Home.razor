@page "/bewasmodsync"
@layout MainLayout

@using BewasModSync.Models
@using BewasModSync.Services
@using Color = MudBlazor.Color
@using System.Linq
@using Microsoft.JSInterop

@inject ConfigService ConfigService
@inject ModDownloadService ModDownloadService
@inject ModInstallService ModInstallService
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime JS

<MudContainer MaxWidth="MaxWidth.ExtraLarge">
    <!-- Header Section -->
    <MudPaper Class="pa-6 mb-4" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 12px; margin-top: 55px;">
        <div class="d-flex justify-space-between align-center">
            <div>
                <MudText Typo="Typo.h4" Style="color: var(--text-primary); font-weight: 700;">SPT Server Mod Manager</MudText>
                <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">
                    Add mods to be installed on your SPT server. Clients will automatically sync from the installed files on the server.
                </MudText>
            </div>
            <div class="d-flex gap-2">
                @if (ConfigService.HasPendingChanges())
                {
                    <MudButton Variant="Variant.Filled" 
                               StartIcon="@Icons.Material.Filled.PlayArrow" 
                               Color="Color.Success"
                               Style="font-weight: 600;"
                               OnClick="ApplyChanges"
                               Disabled="_isApplying">
                        @if (_isApplying)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Applying...</span>
                        }
                        else
                        {
                            <span>Apply Changes</span>
                        }
                    </MudButton>
                }
                <MudButton Variant="Variant.Filled" 
                           StartIcon="@Icons.Material.Filled.Add" 
                           Color="Color.Primary"
                           Style="background: var(--accent-cyan); color: #000; font-weight: 600;"
                           OnClick="OpenAddModsDialog">
                    Add Mods
                </MudButton>
            </div>
        </div>
        
        @if (ConfigService.HasPendingChanges())
        {
            <MudAlert Severity="Severity.Warning" Class="mt-4" Dense="true">
                You have pending changes. Click "Apply Changes" to install/remove mods.
                @{
                    var pendingInstalls = ConfigService.Config.ModList.Count(m => m.Status == ModStatus.Pending);
                    var pendingRemovals = ConfigService.Config.ModList.Count(m => m.Status == ModStatus.PendingRemoval);
                }
                @if (pendingInstalls > 0)
                {
                    <span class="ml-2">üì¶ @pendingInstalls to install</span>
                }
                @if (pendingRemovals > 0)
                {
                    <span class="ml-2">üóëÔ∏è @pendingRemovals to remove</span>
                }
            </MudAlert>
        }
    </MudPaper>

    <!-- Stats Bar -->
    <MudGrid Class="mb-4">
        <MudItem xs="12" sm="3">
            <MudPaper Class="pa-4" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                <div class="d-flex align-center">
                    <MudIcon Icon="@Icons.Material.Filled.Extension" Style="color: var(--accent-cyan);" Class="mr-3" Size="Size.Large"/>
                    <div>
                        <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@ConfigService.Config.ModList.Count</MudText>
                        <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Total Mods</MudText>
                    </div>
                </div>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" sm="3">
            <MudPaper Class="pa-4" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                <div class="d-flex align-center">
                    <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Style="color: var(--accent-green);" Class="mr-3" Size="Size.Large"/>
                    <div>
                        <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@ConfigService.Config.ModList.Count(m => m.Status == ModStatus.Installed)</MudText>
                        <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Installed</MudText>
                    </div>
                </div>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" sm="3">
            <MudPaper Class="pa-4" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                <div class="d-flex align-center">
                    <MudIcon Icon="@Icons.Material.Filled.Pending" Style="color: var(--accent-orange);" Class="mr-3" Size="Size.Large"/>
                    <div>
                        <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@ConfigService.Config.ModList.Count(m => m.Status == ModStatus.Pending)</MudText>
                        <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Pending Install</MudText>
                    </div>
                </div>
            </MudPaper>
        </MudItem>
        <MudItem xs="12" sm="3">
            <MudPaper Class="pa-4" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                <div class="d-flex align-center">
                    <MudIcon Icon="@Icons.Material.Filled.Lock" Style="color: var(--accent-red);" Class="mr-3" Size="Size.Large"/>
                    <div>
                        <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@ConfigService.Config.ModList.Count(m => !m.Optional)</MudText>
                        <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Required</MudText>
                    </div>
                </div>
            </MudPaper>
        </MudItem>
    </MudGrid>

    <MudTabs ActivePanelIndex="@_activeTabIndex"
             ActivePanelIndexChanged="OnTabChanged"
             Class="mb-4">
        <MudTabPanel Text="Mods">
            <!-- Mod Cards -->
            @if (ConfigService.Config.ModList.Count == 0)
            {
                <MudPaper Class="pa-8 text-center" Style="background: var(--card-bg); border: 2px dashed var(--border-color); border-radius: 12px;">
                    <MudIcon Icon="@Icons.Material.Filled.Inventory2" Size="Size.Large" Style="color: var(--text-secondary); font-size: 4rem;" />
                    <MudText Typo="Typo.h6" Class="mt-4" Style="color: var(--text-secondary);">No mods configured yet</MudText>
                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Click "Add Mods" to get started</MudText>
                </MudPaper>
            }
            else
            {
                <MudGrid>
                    @foreach (var mod in ConfigService.Config.ModList)
                    {
                        <MudItem xs="12" md="6" lg="4">
                            <MudPaper Class="pa-4" Style="@GetModCardStyle(mod)">
                                <div class="d-flex justify-space-between align-start mb-3">
                                    <div>
                                        <MudText Typo="Typo.h6" Style="color: var(--text-primary); font-weight: 600;">@mod.ModName</MudText>
                                        <div class="d-flex gap-1 flex-wrap mt-1">
                                            <MudChip T="string" Size="Size.Small" Style="@GetStatusChipStyle(mod.Status)">
                                                @GetStatusText(mod.Status)
                                            </MudChip>
                                            <MudChip T="string" Size="Size.Small" 
                                                     Style="@(mod.Optional ? "background: var(--accent-green); color: #000;" : "background: var(--accent-orange); color: #000;")">
                                                @(mod.Optional ? "Optional" : "Required")
                                            </MudChip>
                                        </div>
                                    </div>
                                    <MudMenu Icon="@Icons.Material.Filled.MoreVert" Dense="true">
                                        <MudMenuItem OnClick="@(() => EditMod(mod))">
                                            <MudIcon Icon="@Icons.Material.Filled.Edit" Size="Size.Small" Class="mr-2" /> Edit
                                        </MudMenuItem>
                                        @if (mod.Status == ModStatus.Installed)
                                        {
                                            <MudMenuItem OnClick="@(() => ReinstallMod(mod))">
                                                <MudIcon Icon="@Icons.Material.Filled.Refresh" Size="Size.Small" Class="mr-2" /> Reinstall
                                            </MudMenuItem>
                                        }
                                        <MudMenuItem OnClick="@(() => DeleteMod(mod))" Style="color: var(--accent-red);">
                                            <MudIcon Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Class="mr-2" /> 
                                            @(mod.Status == ModStatus.Pending ? "Remove" : "Uninstall")
                                        </MudMenuItem>
                                    </MudMenu>
                                </div>

                                <MudText Typo="Typo.body2" Class="mono mb-2" Style="color: var(--text-secondary); word-break: break-all; font-size: 0.75rem;">
                                    @TruncateUrl(mod.DownloadUrl)
                                </MudText>

                                <MudDivider Class="my-3" Style="border-color: var(--border-color);" />

                                <MudText Typo="Typo.caption" Style="color: var(--text-secondary);">
                                    <MudIcon Icon="@Icons.Material.Filled.Schedule" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                                    Updated: @FormatTimestamp(mod.LastUpdated)
                                </MudText>

                                <MudText Typo="Typo.caption" Class="mt-1 d-block" Style="color: var(--text-secondary);">
                                    <MudIcon Icon="@Icons.Material.Filled.Folder" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                                    @mod.InstallPaths.Count install path(s)
                                </MudText>
                            </MudPaper>
                        </MudItem>
                    }
                </MudGrid>
            }
        </MudTabPanel>

        <MudTabPanel Text="Sync Exclusions">
            <MudPaper Class="pa-4" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                <MudText Typo="Typo.h6" Style="color: var(--text-primary); font-weight: 600;">Sync Exclusions</MudText>
                <MudText Typo="Typo.body2" Class="mb-3" Style="color: var(--text-secondary);">
                    Files under <code>BepInEx/plugins</code> and <code>SPT/user/mods</code> are synced to clients by default.
                    Uncheck items to exclude server-only/generated files from the manifest and client warnings.
                </MudText>

                <div class="d-flex gap-2 mb-3">
                    <MudButton Variant="Variant.Outlined"
                               StartIcon="@Icons.Material.Filled.Refresh"
                               Disabled="_syncExclusionsLoading"
                               OnClick="LoadSyncExclusionsTreeAsync">
                        Refresh
                    </MudButton>
                    <MudButton Color="Color.Success"
                               Variant="Variant.Filled"
                               StartIcon="@Icons.Material.Filled.Save"
                               Disabled="_syncExclusionsLoading"
                               OnClick="SaveSyncExclusionsAsync">
                        Save Exclusions
                    </MudButton>
                </div>

                @if (_syncExclusionsLoading)
                {
                    <div class="d-flex align-center mb-2">
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <MudText Typo="Typo.body2">Scanning mod folders...</MudText>
                    </div>
                }
                else if (!string.IsNullOrEmpty(_syncExclusionsError))
                {
                    <MudAlert Severity="Severity.Warning">@_syncExclusionsError</MudAlert>
                }
                else if (_syncTreeRoot != null && _syncTreeRoot.Children != null && _syncTreeRoot.Children.Any())
                {
                    <MudPaper Class="pa-3" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); max-height: 420px; overflow-y: auto;">
                        <div class="mb-2" style="font-size:13px; color: var(--text-secondary);">
                            ‚úì Checked = sync to client &nbsp;|&nbsp; ‚òê Unchecked = exclude
                        </div>
                        @foreach (var (node, depth) in GetSyncFlattenedTree())
                        {
                            var state = GetSyncNodeState(node);
                            var indent = depth * 18;
                            var capturedNode = node;
                            var isExpanded = node.IsDirectory && _syncExpandedDirs.Contains(node.RelativePath);
                            var hasChildren = node.IsDirectory && node.Children?.Count > 0;
                            <div class="d-flex align-center" style="padding-left:@(indent)px; margin-bottom:2px;">
                                @* Expand/collapse button for directories *@
                                @if (hasChildren)
                                {
                                    <MudIconButton Icon="@(isExpanded ? Icons.Material.Filled.Remove : Icons.Material.Filled.Add)"
                                                   Size="Size.Small"
                                                   Style="padding: 2px; min-width: 24px; color: var(--text-secondary);"
                                                   OnClick="() => ToggleSyncExpand(capturedNode)" />
                                }
                                else
                                {
                                    <div style="width: 28px;"></div>
                                }
                                @* Checkbox for sync state *@
                                @{
                                    var checkIcon = state switch
                                    {
                                        SyncNodeState.Included => Icons.Material.Filled.CheckBox,
                                        SyncNodeState.Excluded => Icons.Material.Filled.CheckBoxOutlineBlank,
                                        _ => Icons.Material.Filled.IndeterminateCheckBox
                                    };
                                    var iconColor = state switch
                                    {
                                        SyncNodeState.Included => "var(--accent-green)",
                                        SyncNodeState.Excluded => "var(--text-secondary)",
                                        _ => "var(--accent-orange)"
                                    };
                                }
                                <MudIconButton Icon="@checkIcon"
                                               Size="Size.Small"
                                               Style="@($"padding: 2px; min-width: 24px; color: {iconColor};")"
                                               OnClick="() => OnSyncNodeClick(capturedNode)" />
                                @* Directory/file name (click to expand/collapse for directories) *@
                                @if (node.IsDirectory && hasChildren)
                                {
                                    <span class="ml-1 mono" style="color: var(--text-primary); cursor: pointer;" @onclick="() => ToggleSyncExpand(capturedNode)">
                                        üìÅ @(node.Name)
                                    </span>
                                }
                                else
                                {
                                    <span class="ml-1 mono" style="color: var(--text-primary);">
                                        @(node.IsDirectory ? "üìÅ" : "üìÑ") @(node.Name)
                                    </span>
                                }
                            </div>
                        }
                    </MudPaper>
                }
                else
                {
                    <MudAlert Severity="Severity.Info">
                        No files found in the tracked directories. Install mods or refresh.
                    </MudAlert>
                }
            </MudPaper>
        </MudTabPanel>
    </MudTabs>
</MudContainer>

<!-- Add Mods Dialog (Bulk) -->
<MudDialog @bind-Visible="_addDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true, CloseOnEscapeKey = false, BackdropClick = false })">
    <TitleContent>
        <MudText Typo="Typo.h6" Style="color: var(--text-primary);">
            @if (_addDialogStep == AddDialogStep.Input)
            {
                <span>Add Mods</span>
            }
            else if (_addDialogStep == AddDialogStep.Downloading)
            {
                <span>Downloading Mods...</span>
            }
            else
            {
                <span>Results</span>
            }
        </MudText>
    </TitleContent>
    <DialogContent>
        @if (_addDialogStep == AddDialogStep.Input)
        {
            <MudText Typo="Typo.body2" Class="mb-4" Style="color: var(--text-secondary);">
                Enter direct download links (one per line or separated by whitespace). 
                Mod names will be auto-generated from filenames.
            </MudText>
            
            <MudTextField @bind-Value="_bulkUrls" 
                          Label="Download URLs" 
                          Variant="Variant.Outlined"
                          Lines="8"
                          Placeholder="https://github.com/example/mod/releases/download/v1.0/ModName.zip&#10;https://github.com/another/mod.7z"
                          Class="mb-4 mono" />
            
            <MudCheckBox @bind-Value="_bulkOptional" 
                         Label="Mark all as optional (not enforced on clients)"
                         Color="Color.Primary" />
        }
        else if (_addDialogStep == AddDialogStep.Downloading)
        {
            <div class="pa-4">
                <MudText Typo="Typo.body1" Class="mb-2" Style="color: var(--text-primary);">
                    Processing @(_currentDownloadIndex + 1) of @_urlsToProcess.Count
                </MudText>
                <MudProgressLinear Value="@((_currentDownloadIndex + 1) * 100.0 / _urlsToProcess.Count)" 
                                   Color="Color.Primary" 
                                   Rounded="true" 
                                   Size="Size.Large"
                                   Class="mb-4" />
                
                <MudText Typo="Typo.body2" Class="mono" Style="color: var(--text-secondary); word-break: break-all;">
                    @(_currentDownloadUrl ?? "Starting...")
                </MudText>
                
                @if (_downloadResults.Count > 0)
                {
                    <MudDivider Class="my-4" />
                    <MudText Typo="Typo.subtitle2" Class="mb-2" Style="color: var(--text-secondary);">
                        Completed: @_downloadResults.Count(r => r.Success) succeeded, @_downloadResults.Count(r => !r.Success) failed
                    </MudText>
                }
            </div>
        }
        else if (_addDialogStep == AddDialogStep.Results)
        {
            <div class="pa-2">
                @{ 
                    var successes = _downloadResults.Where(r => r.Success).ToList();
                    var failures = _downloadResults.Where(r => !r.Success).ToList();
                }
                
                @if (successes.Count > 0)
                {
                    <MudAlert Severity="Severity.Success" Class="mb-4">
                        Successfully staged @successes.Count mod(s) for installation
                    </MudAlert>
                    
                    <MudText Typo="Typo.subtitle2" Class="mb-2" Style="color: var(--accent-green);">
                        ‚úì Staged Mods (click "Apply Changes" to install)
                    </MudText>
                    <MudList T="string" Dense="true" Class="mb-4">
                        @foreach (var result in successes)
                        {
                            <MudListItem T="string" Icon="@Icons.Material.Filled.CheckCircle" IconColor="Color.Success">
                                <MudText Style="color: var(--text-primary);">@result.ModName</MudText>
                                <MudText Typo="Typo.caption" Style="color: var(--text-secondary);">
                                    @result.SuggestedInstallPaths.Count install path(s) configured
                                </MudText>
                            </MudListItem>
                        }
                    </MudList>
                }
                
                @if (failures.Count > 0)
                {
                    <MudAlert Severity="Severity.Error" Class="mb-4">
                        Failed to download @failures.Count mod(s)
                    </MudAlert>
                    
                    <MudText Typo="Typo.subtitle2" Class="mb-2" Style="color: var(--accent-red);">
                        ‚úó Failed Downloads
                    </MudText>
                    <MudList T="string" Dense="true">
                        @foreach (var result in failures)
                        {
                            <MudListItem T="string" Icon="@Icons.Material.Filled.Error" IconColor="Color.Error">
                                <MudText Style="color: var(--text-primary); word-break: break-all; font-size: 0.85rem;">
                                    @TruncateUrl(result.Url)
                                </MudText>
                                <MudText Typo="Typo.caption" Style="color: var(--accent-red);">
                                    @result.Error
                                </MudText>
                            </MudListItem>
                        }
                    </MudList>
                }
            </div>
        }
    </DialogContent>
    <DialogActions>
        @if (_addDialogStep == AddDialogStep.Input)
        {
            <MudButton OnClick="CloseAddDialog" Variant="Variant.Text">Cancel</MudButton>
            <MudButton Color="Color.Primary" 
                       Variant="Variant.Filled"
                       Disabled="@(string.IsNullOrWhiteSpace(_bulkUrls))"
                       OnClick="ProcessBulkDownload">
                Download & Stage
            </MudButton>
        }
        else if (_addDialogStep == AddDialogStep.Downloading)
        {
            <MudText Typo="Typo.caption" Style="color: var(--text-secondary);">
                Please wait...
            </MudText>
        }
        else if (_addDialogStep == AddDialogStep.Results)
        {
            <MudButton Color="Color.Primary" 
                       Variant="Variant.Filled"
                       OnClick="CloseAddDialog">
                Done
            </MudButton>
        }
    </DialogActions>
</MudDialog>

<!-- Edit Mod Dialog -->
<MudDialog @bind-Visible="_editDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true })">
        <TitleContent>
            <MudText Typo="Typo.h6" Style="color: var(--text-primary);">Edit Mod</MudText>
        </TitleContent>
        <DialogContent>
            <MudTextField @bind-Value="_editModName" 
                          Label="Mod Name" 
                          Variant="Variant.Outlined"
                          Class="mb-4"
                          Required="true" />
            
            <MudTextField Value="@_editDownloadUrl" 
                          Label="Download URL" 
                          Variant="Variant.Outlined"
                          Class="mb-4 mono"
                          ReadOnly="true"
                          HelperText="URL cannot be changed. Delete and re-add to use a different URL." />
            
            <MudCheckBox @bind-Value="_editIsOptional" 
                         Label="Optional mod (not enforced on clients)"
                         Color="Color.Primary"
                         Class="mb-4" />

            <MudText Typo="Typo.subtitle1" Class="mt-4 mb-2" Style="color: var(--text-primary); font-weight: 600;">
                Install Paths
            </MudText>
            
            @if (_editInstallPaths != null)
            {
                @for (int i = 0; i < _editInstallPaths.Count; i++)
                {
                    var index = i;
                    <MudPaper Class="pa-3 mb-2" Style="background: var(--secondary-bg); border: 1px solid var(--border-color);">
                        <MudGrid>
                            <MudItem xs="5">
                                <MudTextField @bind-Value="_editInstallPaths[index].Source" 
                                              Label="Source Path" 
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Class="mono" />
                            </MudItem>
                            <MudItem xs="1" Class="d-flex align-center justify-center">
                                <MudIcon Icon="@Icons.Material.Filled.ArrowForward" />
                            </MudItem>
                            <MudItem xs="5">
                                <MudTextField @bind-Value="_editInstallPaths[index].Target" 
                                              Label="Target Path" 
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Class="mono" />
                            </MudItem>
                            <MudItem xs="1" Class="d-flex align-center justify-center">
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                               Color="Color.Error" 
                                               Size="Size.Small"
                                               OnClick="@(() => RemoveEditInstallPath(index))" />
                            </MudItem>
                        </MudGrid>
                    </MudPaper>
                }
            }

            <MudButton Variant="Variant.Text" 
                       StartIcon="@Icons.Material.Filled.Add" 
                       Color="Color.Primary"
                       OnClick="AddEditInstallPath"
                       Class="mt-2">
                Add Install Path
            </MudButton>

            <MudDivider Class="my-4" />

            <MudText Typo="Typo.subtitle1" Class="mb-1" Style="color: var(--text-primary); font-weight: 600;">
                File Copy Rules (per-file overwrite/ignore)
            </MudText>
            <MudText Typo="Typo.caption" Class="mb-3" Style="color: var(--text-secondary);">
                Default is overwrite. Mark specific files as "Ignore" to keep your server-side edits when installing/reinstalling.  
                This is useful for config files that you want to keep your server-side edits for.
                This only affects the files that are installed on the server.  
                If you're unsure, leave it as overwrite.  
            </MudText>

            @if (_fileRulesLoading)
            {
                <div class="d-flex align-center mb-3">
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <MudText Typo="Typo.body2">Loading file tree...</MudText>
                </div>
            }
            else if (!string.IsNullOrEmpty(_fileRulesError))
            {
                <MudAlert Severity="Severity.Warning" Class="mb-3">
                    @_fileRulesError
                </MudAlert>
            }
            else if (_fileTreeRoot != null && _fileTreeRoot.Children != null && _fileTreeRoot.Children.Any())
            {
                <MudPaper Class="pa-3" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); max-height: 360px; overflow-y: auto;">
                    <div class="mb-2" style="font-size:13px; color: var(--text-secondary);">
                        <span class="mr-3"><MudChip T="string" Color="Color.Success" Variant="Variant.Outlined" Size="Size.Small">Overwrite</MudChip></span>
                        <span><MudChip T="string" Color="Color.Default" Variant="Variant.Filled" Size="Size.Small">Ignore</MudChip></span>
                    </div>
                    @foreach (var item in GetFlattenedTree())
                    {
                        var node = item.Node;
                        var depth = item.Depth;
                        var state = GetNodeState(node);
                        <div class="d-flex align-center" style="padding-left:@(depth * 14)px; margin-bottom:4px;">
                            <MudChip T="string" 
                                     Color="@(state == FileRuleState.Ignore ? Color.Default : state == FileRuleState.Mixed ? Color.Info : Color.Success)"
                                     Variant="@(state == FileRuleState.Ignore ? Variant.Filled : Variant.Outlined)"
                                     Size="Size.Small"
                                     OnClick="@(() => ToggleNode(node))">
                                @(state == FileRuleState.Ignore ? "Ignore" : state == FileRuleState.Mixed ? "Mixed" : "Overwrite")
                            </MudChip>
                            <span class="ml-2 mono" style="color: var(--text-primary);">
                                @(node.IsDirectory ? "üìÅ" : "üìÑ") @node.Name
                            </span>
                        </div>
                    }
                </MudPaper>
            }
            else
            {
                <MudAlert Severity="Severity.Info">
                    No files found in staging for this mod. Reinstall to refresh the file list.
                </MudAlert>
            }
        </DialogContent>
        <DialogActions>
            <MudButton OnClick="CloseEditDialog" Variant="Variant.Text">Cancel</MudButton>
            <MudButton Color="Color.Primary" 
                       Variant="Variant.Filled"
                       Disabled="@(string.IsNullOrWhiteSpace(_editModName) || (_editInstallPaths?.Count ?? 0) == 0)"
                       OnClick="SaveEditMod">
                Save Changes
            </MudButton>
        </DialogActions>
</MudDialog>

<!-- Apply Changes Result Dialog -->
<MudDialog @bind-Visible="_applyResultDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6" Style="color: var(--text-primary);">Apply Changes Result</MudText>
    </TitleContent>
    <DialogContent>
        @if (_applyResult != null)
        {
            @if (_applyResult.InstalledMods.Count > 0)
            {
                <MudAlert Severity="Severity.Success" Class="mb-3">
                    <MudText Typo="Typo.subtitle2">‚úì Installed @_applyResult.InstalledMods.Count mod(s):</MudText>
                    @foreach (var mod in _applyResult.InstalledMods)
                    {
                        <MudText Typo="Typo.body2" Class="ml-3">‚Ä¢ @mod</MudText>
                    }
                </MudAlert>
            }
            
            @if (_applyResult.QueuedForInstall.Count > 0)
            {
                <MudAlert Severity="Severity.Info" Class="mb-3">
                    <MudText Typo="Typo.subtitle2">üì¶ @_applyResult.QueuedForInstall.Count mod(s) will be installed on server restart:</MudText>
                    @foreach (var mod in _applyResult.QueuedForInstall)
                    {
                        <MudText Typo="Typo.body2" Class="ml-3">‚Ä¢ @mod</MudText>
                    }
                </MudAlert>
            }
            
            @if (_applyResult.QueuedForRemoval.Count > 0)
            {
                <MudAlert Severity="Severity.Info" Class="mb-3">
                    <MudText Typo="Typo.subtitle2">üóëÔ∏è @_applyResult.QueuedForRemoval.Count mod(s) will be removed on server restart:</MudText>
                    @foreach (var mod in _applyResult.QueuedForRemoval)
                    {
                        <MudText Typo="Typo.body2" Class="ml-3">‚Ä¢ @mod</MudText>
                    }
                </MudAlert>
            }
            
            @if (_applyResult.Errors.Count > 0)
            {
                <MudAlert Severity="Severity.Error" Class="mb-3">
                    <MudText Typo="Typo.subtitle2">‚ùå Errors:</MudText>
                    @foreach (var error in _applyResult.Errors)
                    {
                        <MudText Typo="Typo.body2" Class="ml-3">‚Ä¢ @error</MudText>
                    }
                </MudAlert>
            }
            
            @if (_applyResult.AutoInstallerLaunched)
            {
                <MudAlert Severity="Severity.Success" Class="mt-4">
                    <MudText Typo="Typo.subtitle2">üöÄ Auto-Installer Launched!</MudText>
                    <MudText Typo="Typo.body2" Class="mt-2">
                        A PowerShell window has opened that will automatically install the pending mods
                        when you stop the SPT server.
                    </MudText>
                    <MudText Typo="Typo.body2" Class="mt-2">
                        <strong>Just stop the server normally</strong> - the installer will detect it and complete the installation.
                    </MudText>
                </MudAlert>
            }
            else if (_applyResult.QueuedForInstall.Count > 0)
            {
                <MudAlert Severity="Severity.Info" Class="mt-4">
                    <MudText Typo="Typo.body2">
                        @(_applyResult.QueuedForInstall.Count) mod(s) queued for installation on next server restart.
                    </MudText>
                </MudAlert>
            }
        }
    </DialogContent>
    <DialogActions>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="@(() => _applyResultDialogVisible = false)">
            OK
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    private bool _hasLoggedInit = false;
    private int _activeTabIndex = 0;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_hasLoggedInit)
        {
            _hasLoggedInit = true;
            await JS.InvokeVoidAsync("console.log", "[BewasModSync] Frontend loaded!");
        }
    }
    
    // State
    private bool _isApplying = false;
    private ApplyChangesResult? _applyResult;
    private bool _applyResultDialogVisible = false;

    // Add Mods Dialog (Bulk)
    private bool _addDialogVisible = false;
    private AddDialogStep _addDialogStep = AddDialogStep.Input;
    private string _bulkUrls = "";
    private bool _bulkOptional = false;
    private List<string> _urlsToProcess = new();
    private int _currentDownloadIndex = 0;
    private string? _currentDownloadUrl;
    private List<ModDownloadResult> _downloadResults = new();

    private enum AddDialogStep { Input, Downloading, Results }

    // Edit Mod Dialog
    private bool _editDialogVisible = false;
    private ModEntry? _editingMod = null;
    private string _editModName = "";
    private string _editDownloadUrl = "";
    private bool _editIsOptional = false;
    private List<InstallPathItem> _editInstallPaths = new();

    private class InstallPathItem
    {
        public string Source { get; set; } = "";
        public string Target { get; set; } = "";
    }

    // Sync exclusions (manifest opt-out)
    private bool _syncExclusionsLoading = false;
    private string? _syncExclusionsError;
    private bool _syncTabInitialized = false;
    private FileNode? _syncTreeRoot;
    private HashSet<string> _syncExclusionSet = new(StringComparer.OrdinalIgnoreCase);
    private HashSet<string> _syncExpandedDirs = new(StringComparer.OrdinalIgnoreCase);

    private enum SyncNodeState { Included, Excluded, Mixed }

    // File rules for install (overwrite/ignore)
    private enum FileRuleState { Overwrite, Ignore, Mixed }

    private class FileNode
    {
        public string Name { get; set; } = "";
        public string RelativePath { get; set; } = "";
        public bool IsDirectory { get; set; }
        public List<FileNode> Children { get; set; } = new();
    }

    private FileNode? _fileTreeRoot;
    private HashSet<string> _fileRulesIgnore = new(StringComparer.OrdinalIgnoreCase);
    private bool _fileRulesLoading = false;
    private string? _fileRulesError;

    // Apply Changes
    private async Task ApplyChanges()
    {
        _isApplying = true;
        StateHasChanged();

        try
        {
            _applyResult = await ModInstallService.ApplyPendingChangesAsync();
            _applyResultDialogVisible = true;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error applying changes: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isApplying = false;
            StateHasChanged();
        }
    }

    // Add Mods Dialog Methods
    private void OpenAddModsDialog()
    {
        _bulkUrls = "";
        _bulkOptional = false;
        _urlsToProcess = new();
        _downloadResults = new();
        _currentDownloadIndex = 0;
        _currentDownloadUrl = null;
        _addDialogStep = AddDialogStep.Input;
        _addDialogVisible = true;
    }

    private async Task ProcessBulkDownload()
    {
        _urlsToProcess = _bulkUrls
            .Split(new[] { '\n', '\r', ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(u => u.Trim())
            .Where(u => !string.IsNullOrWhiteSpace(u) && (u.StartsWith("http://") || u.StartsWith("https://")))
            .Distinct()
            .ToList();

        if (_urlsToProcess.Count == 0)
        {
            Snackbar.Add("No valid URLs found. Please enter direct download links.", Severity.Warning);
            return;
        }

        _downloadResults = new();
        _currentDownloadIndex = 0;
        _addDialogStep = AddDialogStep.Downloading;
        await InvokeAsync(StateHasChanged);

        foreach (var url in _urlsToProcess)
        {
            _currentDownloadUrl = url;
            await InvokeAsync(StateHasChanged);

            try
            {
                var result = await ModDownloadService.DownloadAndAnalyzeModAsync(url);
                
                if (result.Success && string.IsNullOrWhiteSpace(result.ModName))
                {
                    result.ModName = ExtractModNameFromUrl(url);
                }

                _downloadResults.Add(result);

                if (result.Success && result.SuggestedInstallPaths.Count > 0)
                {
                    var mod = new ModEntry
                    {
                        ModName = result.ModName ?? ExtractModNameFromUrl(url),
                        DownloadUrl = url,
                        Optional = _bulkOptional,
                        LastUpdated = DateTime.UtcNow.ToString("o"),
                        InstallPaths = result.SuggestedInstallPaths,
                        Status = ModStatus.Pending // New mods start as pending
                    };
                    await ConfigService.AddModAsync(mod);
                }
            }
            catch (Exception ex)
            {
                _downloadResults.Add(new ModDownloadResult
                {
                    Url = url,
                    Success = false,
                    Error = ex.Message
                });
            }

            _currentDownloadIndex++;
            await InvokeAsync(StateHasChanged);
        }

        _addDialogStep = AddDialogStep.Results;
        await InvokeAsync(StateHasChanged);
    }

    private string ExtractModNameFromUrl(string url)
    {
        try
        {
            var uri = new Uri(url);
            var filename = Path.GetFileName(uri.LocalPath);
            
            var extensions = new[] { ".zip", ".7z", ".rar", ".tar.gz", ".tar", ".gz" };
            foreach (var ext in extensions)
            {
                if (filename.EndsWith(ext, StringComparison.OrdinalIgnoreCase))
                {
                    filename = filename.Substring(0, filename.Length - ext.Length);
                    break;
                }
            }
            
            return string.IsNullOrWhiteSpace(filename) ? "UnknownMod" : filename;
        }
        catch
        {
            return "UnknownMod";
        }
    }

    private void CloseAddDialog()
    {
        _addDialogVisible = false;
        _addDialogStep = AddDialogStep.Input;
        StateHasChanged();
    }

    #region Sync Exclusions (manifest opt-out)

    private async Task OnTabChanged(int index)
    {
        _activeTabIndex = index;

        if (index == 1 && !_syncTabInitialized)
        {
            await LoadSyncExclusionsTreeAsync();
        }
    }

    private async Task LoadSyncExclusionsTreeAsync()
    {
        _syncExclusionsLoading = true;
        _syncExclusionsError = null;
        await InvokeAsync(StateHasChanged);

        try
        {
            _syncExclusionSet = new HashSet<string>(
                (ConfigService.Config.SyncExclusions ?? new List<string>())
                    .Select(NormalizeRulePath)
                    .Where(p => !string.IsNullOrWhiteSpace(p)),
                StringComparer.OrdinalIgnoreCase);

            var root = new FileNode { Name = "root", IsDirectory = true, RelativePath = "" };

            AddSyncRoot(ConfigService.BepInExPluginsPath, "BepInEx/plugins", root);
            AddSyncRoot(ConfigService.SptUserModsPath, "SPT/user/mods", root);

            _syncTreeRoot = root;
            _syncTabInitialized = true;
        }
        catch (Exception ex)
        {
            _syncExclusionsError = $"Failed to load exclusions: {ex.Message}";
        }
        finally
        {
            _syncExclusionsLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void AddSyncRoot(string absolutePath, string relativePath, FileNode root)
    {
        if (!Directory.Exists(absolutePath)) return;

        var node = BuildSyncNodeRecursive(absolutePath, NormalizeRulePath(relativePath), relativePath);
        root.Children.Add(node);
    }

    private FileNode BuildSyncNodeRecursive(string fullPath, string relativePath, string? displayName = null)
    {
        var node = new FileNode
        {
            Name = displayName ?? Path.GetFileName(fullPath),
            RelativePath = relativePath,
            IsDirectory = true
        };

        foreach (var dir in Directory.GetDirectories(fullPath))
        {
            var childRel = NormalizeRulePath(Path.Combine(relativePath, Path.GetFileName(dir)));
            node.Children.Add(BuildSyncNodeRecursive(dir, childRel));
        }

        foreach (var file in Directory.GetFiles(fullPath))
        {
            var childRel = NormalizeRulePath(Path.Combine(relativePath, Path.GetFileName(file)));
            node.Children.Add(new FileNode
            {
                Name = Path.GetFileName(file),
                RelativePath = childRel,
                IsDirectory = false
            });
        }

        return node;
    }

    private SyncNodeState GetSyncNodeState(FileNode? node)
    {
        if (node == null) return SyncNodeState.Included;

        var rel = NormalizeRulePath(node.RelativePath);

        if (!node.IsDirectory)
        {
            var isExcluded = IsSyncExcluded(rel);
            return isExcluded ? SyncNodeState.Excluded : SyncNodeState.Included;
        }

        // For directories: derive state from all leaf nodes
        var leaves = GetSyncLeafNodes(node).ToList();
        if (leaves.Count == 0) return SyncNodeState.Included;
        
        var leafStates = leaves.Select(leaf => IsSyncExcluded(NormalizeRulePath(leaf.RelativePath)) ? SyncNodeState.Excluded : SyncNodeState.Included).Distinct().ToList();
        if (leafStates.Count == 1) return leafStates[0];
        return SyncNodeState.Mixed;
    }

    private IEnumerable<FileNode> GetSyncLeafNodes(FileNode? node)
    {
        if (node == null) yield break;

        if (!node.IsDirectory)
        {
            yield return node;
            yield break;
        }

        var children = node.Children;
        if (children == null) yield break;

        foreach (var child in children)
        {
            foreach (var leaf in GetSyncLeafNodes(child))
                yield return leaf;
        }
    }

    private bool IsSyncExcluded(string relativePath)
    {
        var norm = NormalizeRulePath(relativePath);
        return _syncExclusionSet.Any(ex =>
            norm.Equals(ex, StringComparison.OrdinalIgnoreCase) ||
            norm.StartsWith(ex + "/", StringComparison.OrdinalIgnoreCase));
    }

    private void OnSyncNodeClick(FileNode node)
    {
        _ = ToggleSyncNodeAsync(node);
    }

    private void ToggleSyncExpand(FileNode node)
    {
        if (!node.IsDirectory) return;
        
        var path = node.RelativePath;
        if (_syncExpandedDirs.Contains(path))
            _syncExpandedDirs.Remove(path);
        else
            _syncExpandedDirs.Add(path);
        
        StateHasChanged();
    }

    private Task ToggleSyncNodeAsync(FileNode? node)
    {
        if (node == null) return Task.CompletedTask;

        var current = GetSyncNodeState(node);
        var next = current == SyncNodeState.Excluded ? SyncNodeState.Included : SyncNodeState.Excluded;

        if (node.IsDirectory)
        {
            ApplySyncDirectoryState(node, next);
        }
        else
        {
            ApplySyncFileState(node, next);
        }

        StateHasChanged();
        return Task.CompletedTask;
    }

    private void ApplySyncDirectoryState(FileNode? node, SyncNodeState state)
    {
        if (node == null) return;
        var rel = NormalizeRulePath(node.RelativePath);

        // Clear this directory and all its descendants from exclusions
        foreach (var path in EnumerateSyncAllPaths(node).ToList())
            _syncExclusionSet.Remove(path);

        if (state == SyncNodeState.Excluded && !string.IsNullOrEmpty(rel))
        {
            _syncExclusionSet.Add(rel);
        }
        else if (state == SyncNodeState.Included && !string.IsNullOrEmpty(rel))
        {
            // Check if a PROPER ANCESTOR (not self) is excluded - need to lift it
            var ancestorExclusion = _syncExclusionSet
                .FirstOrDefault(ex => rel.StartsWith(ex + "/", StringComparison.OrdinalIgnoreCase));
            
            if (ancestorExclusion != null)
            {
                _syncExclusionSet.Remove(ancestorExclusion);
                var ancestorNode = FindNodeByPath(_syncTreeRoot, ancestorExclusion);
                if (ancestorNode != null)
                {
                    foreach (var leaf in EnumerateSyncLeafPaths(ancestorNode))
                    {
                        var leafNorm = NormalizeRulePath(leaf);
                        if (!leafNorm.StartsWith(rel + "/", StringComparison.OrdinalIgnoreCase) &&
                            !leafNorm.Equals(rel, StringComparison.OrdinalIgnoreCase))
                        {
                            _syncExclusionSet.Add(leafNorm);
                        }
                    }
                }
            }
        }
    }

    private void ApplySyncFileState(FileNode? node, SyncNodeState state)
    {
        if (node == null) return;
        var rel = NormalizeRulePath(node.RelativePath);

        if (state == SyncNodeState.Excluded)
        {
            _syncExclusionSet.Add(rel);
        }
        else
        {
            var ancestorExclusion = _syncExclusionSet
                .FirstOrDefault(ex => rel.StartsWith(ex + "/", StringComparison.OrdinalIgnoreCase));
            
            if (ancestorExclusion != null)
            {
                _syncExclusionSet.Remove(ancestorExclusion);
                var ancestorNode = FindNodeByPath(_syncTreeRoot, ancestorExclusion);
                if (ancestorNode != null)
                {
                    foreach (var leaf in EnumerateSyncLeafPaths(ancestorNode))
                    {
                        var leafNorm = NormalizeRulePath(leaf);
                        if (!leafNorm.Equals(rel, StringComparison.OrdinalIgnoreCase))
                        {
                            _syncExclusionSet.Add(leafNorm);
                        }
                    }
                }
            }
            _syncExclusionSet.Remove(rel);
        }
    }

    private IEnumerable<string> EnumerateSyncAllPaths(FileNode? node)
    {
        if (node == null) yield break;

        if (!string.IsNullOrEmpty(node.RelativePath))
            yield return NormalizeRulePath(node.RelativePath);

        var children = node.Children ?? Enumerable.Empty<FileNode>();
        foreach (var child in children)
            foreach (var p in EnumerateSyncAllPaths(child))
                yield return p;
    }

    private FileNode? FindNodeByPath(FileNode? node, string relativePath)
    {
        if (node == null) return null;
        var norm = NormalizeRulePath(relativePath);
        if (NormalizeRulePath(node.RelativePath).Equals(norm, StringComparison.OrdinalIgnoreCase))
            return node;

        var children = node.Children ?? Enumerable.Empty<FileNode>();
        foreach (var child in children)
        {
            var found = FindNodeByPath(child, relativePath);
            if (found != null) return found;
        }
        return null;
    }

    private IEnumerable<string> EnumerateSyncLeafPaths(FileNode? node)
    {
        if (node == null) yield break;

        if (!node.IsDirectory)
        {
            if (!string.IsNullOrEmpty(node.RelativePath))
                yield return NormalizeRulePath(node.RelativePath);
            yield break;
        }

        var children = node.Children ?? Enumerable.Empty<FileNode>();
        foreach (var child in children)
        {
            foreach (var leaf in EnumerateSyncLeafPaths(child))
                yield return leaf;
        }
    }

    private List<(FileNode Node, int Depth)> GetSyncFlattenedTree()
    {
        var result = new List<(FileNode, int)>();
        if (_syncTreeRoot?.Children == null) return result;

        void Flatten(FileNode node, int depth)
        {
            if (node == null) return;
            result.Add((node, depth));

            // Only recurse into children if this directory is expanded
            if (node.IsDirectory && !_syncExpandedDirs.Contains(node.RelativePath))
                return;

            var children = node.Children;
            if (children != null)
            {
                foreach (var child in children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
                {
                    Flatten(child, depth + 1);
                }
            }
        }

        foreach (var child in _syncTreeRoot.Children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
        {
            Flatten(child, 0);
        }

        return result;
    }

    private async Task SaveSyncExclusionsAsync()
    {
        try
        {
            ConfigService.Config.SyncExclusions = _syncExclusionSet
                .Select(NormalizeRulePath)
                .Where(p => !string.IsNullOrWhiteSpace(p))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .OrderBy(p => p)
                .ToList();

            await ConfigService.SaveConfigAsync();
            Snackbar.Add("Sync exclusions updated.", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save exclusions: {ex.Message}", Severity.Error);
        }
    }

    #endregion

    // Edit Mod Dialog Methods
    private void EditMod(ModEntry mod)
    {
        try
        {
            _editingMod = mod;
            _editModName = mod.ModName ?? string.Empty;
            _editDownloadUrl = mod.DownloadUrl ?? string.Empty;
            _editIsOptional = mod.Optional;
            
            // Safe handling of InstallPaths which may be null from JSON deserialization
            var installPaths = mod.InstallPaths ?? new List<string[]>();
            _editInstallPaths = installPaths
                .Where(p => p != null && p.Length >= 2)
                .Select(p => new InstallPathItem { Source = p[0] ?? string.Empty, Target = p[1] ?? string.Empty })
                .ToList();
            if (_editInstallPaths.Count == 0)
            {
                _editInstallPaths.Add(new InstallPathItem());
            }
            _editDialogVisible = true;

            // File rule state - safe handling of FileRules
            var rules = mod.FileRules ?? new List<FileCopyRule>();
            _fileRulesIgnore = new HashSet<string>(
                rules.Where(r => r != null && r.State == FileCopyRuleState.Ignore && !string.IsNullOrWhiteSpace(r.Path))
                     .Select(r => NormalizeRulePath(r.Path)),
                StringComparer.OrdinalIgnoreCase);
            _fileRulesError = null;
            _fileTreeRoot = null;
            _fileRulesLoading = true;
            
            // Load file tree asynchronously
            _ = LoadFileTreeAsync(mod);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error opening edit dialog: {ex.Message}", Severity.Error);
            _editDialogVisible = false;
        }
    }

    private void AddEditInstallPath()
    {
        _editInstallPaths.Add(new InstallPathItem());
    }

    private void RemoveEditInstallPath(int index)
    {
        if (index >= 0 && index < _editInstallPaths.Count)
        {
            _editInstallPaths.RemoveAt(index);
        }
    }

    private async Task SaveEditMod()
    {
        if (_editingMod == null) return;

        _editingMod.ModName = _editModName;
        _editingMod.Optional = _editIsOptional;
        _editingMod.InstallPaths = _editInstallPaths.Select(p => new[] { p.Source, p.Target }).ToList();
        _editingMod.FileRules = _fileRulesIgnore
            .Select(p => new FileCopyRule { Path = p, State = FileCopyRuleState.Ignore })
            .ToList();
        
        await ConfigService.SaveConfigAsync();
        Snackbar.Add($"Mod '{_editModName}' updated!", Severity.Success);
        
        CloseEditDialog();
    }

    private void CloseEditDialog()
    {
        _editDialogVisible = false;
        _editingMod = null;
        _fileTreeRoot = null;
        _fileRulesIgnore.Clear();
    }

    // Reinstall Mod
    private async Task ReinstallMod(ModEntry mod)
    {
        var result = await DialogService.ShowMessageBox(
            "Reinstall Mod",
            $"This will re-download and reinstall '{mod.ModName}'. Continue?",
            yesText: "Reinstall", cancelText: "Cancel");

        if (result == true)
        {
            // Clear staging and re-download
            ConfigService.ClearStagingForUrl(mod.DownloadUrl);
            mod.Status = ModStatus.Pending;
            await ConfigService.SaveConfigAsync();
            
            // Trigger download
            var downloadResult = await ModDownloadService.DownloadAndAnalyzeModAsync(mod.DownloadUrl);
            if (downloadResult.Success)
            {
                Snackbar.Add($"Mod '{mod.ModName}' staged for reinstall. Click 'Apply Changes'.", Severity.Success);
            }
            else
            {
                Snackbar.Add($"Failed to download: {downloadResult.Error}", Severity.Error);
            }
            StateHasChanged();
        }
    }

    #region File rules helpers

    private string NormalizeRulePath(string? path)
    {
        if (string.IsNullOrEmpty(path)) return string.Empty;
        return path.Replace("\\", "/").TrimStart('/');
    }

    private async Task LoadFileTreeAsync(ModEntry mod)
    {
        try
        {
            await JS.InvokeVoidAsync("console.log", "[BewasModSync] LoadFileTreeAsync started");
            
            // Safety checks
            var downloadUrl = mod?.DownloadUrl;
            if (string.IsNullOrEmpty(downloadUrl))
            {
                _fileRulesError = "No download URL for this mod.";
                await JS.InvokeVoidAsync("console.log", "[BewasModSync] No download URL");
                return;
            }

            var staging = ConfigService?.Staging;
            if (staging?.UrlToPath == null || !staging.UrlToPath.TryGetValue(downloadUrl, out var stagingPath))
            {
                _fileRulesError = "Staging not found. Reinstall this mod to view files.";
                await JS.InvokeVoidAsync("console.log", "[BewasModSync] Staging not found");
                return;
            }

            if (string.IsNullOrEmpty(stagingPath))
            {
                _fileRulesError = "Staging path is empty. Reinstall this mod.";
                await JS.InvokeVoidAsync("console.log", "[BewasModSync] Staging path empty");
                return;
            }

            var extractedPath = Path.Combine(stagingPath, "extracted");
            await JS.InvokeVoidAsync("console.log", $"[BewasModSync] Checking extracted path: {extractedPath}");
            
            if (!Directory.Exists(extractedPath))
            {
                _fileRulesError = "Staging extraction not found. Reinstall this mod to view files.";
                await JS.InvokeVoidAsync("console.log", "[BewasModSync] Extracted path not found");
                return;
            }

            await JS.InvokeVoidAsync("console.log", "[BewasModSync] Building file tree...");
            var root = new FileNode { Name = "root", IsDirectory = true, RelativePath = "" };

            var installPaths = _editInstallPaths ?? new List<InstallPathItem>();
            await JS.InvokeVoidAsync("console.log", $"[BewasModSync] Install paths count: {installPaths.Count}");
            
            foreach (var install in installPaths
                .Where(p => p != null && !string.IsNullOrWhiteSpace(p.Source))
                .DistinctBy(p => p.Source, StringComparer.OrdinalIgnoreCase))
            {
                var sourcePath = Path.Combine(extractedPath, install.Source);
                await JS.InvokeVoidAsync("console.log", $"[BewasModSync] Processing: {sourcePath}");
                
                if (Directory.Exists(sourcePath))
                {
                    var node = BuildNodeRecursive(sourcePath, NormalizeRulePath(install.Source));
                    MergeNode(root, node);
                }
                else if (File.Exists(sourcePath))
                {
                    AddFileNode(root, NormalizeRulePath(install.Source));
                }
            }

            await JS.InvokeVoidAsync("console.log", $"[BewasModSync] Tree built, children: {root.Children?.Count ?? 0}");
            _fileTreeRoot = root;
            _fileRulesError = null;
        }
        catch (Exception ex)
        {
            _fileRulesError = $"Failed to load file tree: {ex.Message}";
            try { await JS.InvokeVoidAsync("console.error", $"[BewasModSync] LoadFileTreeAsync error: {ex}"); } catch { }
        }
        finally
        {
            _fileRulesLoading = false;
            await JS.InvokeVoidAsync("console.log", "[BewasModSync] LoadFileTreeAsync complete, calling StateHasChanged");
            await InvokeAsync(StateHasChanged);
        }
    }

    private FileNode BuildNodeRecursive(string fullPath, string relativePath)
    {
        var node = new FileNode
        {
            Name = Path.GetFileName(fullPath),
            RelativePath = relativePath,
            IsDirectory = true
        };

        foreach (var dir in Directory.GetDirectories(fullPath))
        {
            var childRel = NormalizeRulePath(Path.Combine(relativePath, Path.GetFileName(dir)));
            node.Children.Add(BuildNodeRecursive(dir, childRel));
        }

        foreach (var file in Directory.GetFiles(fullPath))
        {
            var childRel = NormalizeRulePath(Path.Combine(relativePath, Path.GetFileName(file)));
            node.Children.Add(new FileNode
            {
                Name = Path.GetFileName(file),
                RelativePath = childRel,
                IsDirectory = false
            });
        }

        return node;
    }

    private void MergeNode(FileNode parent, FileNode child)
    {
        var existing = parent.Children.FirstOrDefault(c =>
            c.IsDirectory &&
            c.Name.Equals(child.Name, StringComparison.OrdinalIgnoreCase) &&
            c.RelativePath.Equals(child.RelativePath, StringComparison.OrdinalIgnoreCase));

        if (existing == null)
        {
            parent.Children.Add(child);
            return;
        }

        foreach (var grand in child.Children)
        {
            if (grand.IsDirectory)
            {
                MergeNode(existing, grand);
            }
            else if (!existing.Children.Any(c => !c.IsDirectory && c.RelativePath.Equals(grand.RelativePath, StringComparison.OrdinalIgnoreCase)))
            {
                existing.Children.Add(grand);
            }
        }
    }

    private void AddFileNode(FileNode root, string relativePath)
    {
        var parts = relativePath.Split('/', StringSplitOptions.RemoveEmptyEntries);
        var current = root;
        var accumulated = "";
        for (int i = 0; i < parts.Length; i++)
        {
            accumulated = string.IsNullOrEmpty(accumulated) ? parts[i] : $"{accumulated}/{parts[i]}";
            var part = parts[i];
            var isLast = i == parts.Length - 1;
            if (isLast)
            {
                if (!current.Children.Any(c => !c.IsDirectory && c.Name.Equals(part, StringComparison.OrdinalIgnoreCase)))
                {
                    current.Children.Add(new FileNode
                    {
                        Name = part,
                        RelativePath = accumulated,
                        IsDirectory = false
                    });
                }
            }
            else
            {
                var dir = current.Children.FirstOrDefault(c => c.IsDirectory && c.Name.Equals(part, StringComparison.OrdinalIgnoreCase));
                if (dir == null)
                {
                    dir = new FileNode { Name = part, RelativePath = accumulated, IsDirectory = true };
                    current.Children.Add(dir);
                }
                current = dir;
            }
        }
    }

    private FileRuleState GetNodeState(FileNode? node)
    {
        if (node == null) return FileRuleState.Overwrite;
        
        if (!node.IsDirectory)
        {
            return IsPathIgnored(node.RelativePath) ? FileRuleState.Ignore : FileRuleState.Overwrite;
        }

        var leafStates = GetLeafNodes(node).Select(GetNodeState).Distinct().ToList();
        if (leafStates.Count == 0) return FileRuleState.Overwrite;
        if (leafStates.Count == 1) return leafStates[0];
        return FileRuleState.Mixed;
    }

    private IEnumerable<FileNode> GetLeafNodes(FileNode? node)
    {
        if (node == null) yield break;
        
        if (!node.IsDirectory)
        {
            yield return node;
            yield break;
        }

        var children = node.Children;
        if (children == null) yield break;
        
        foreach (var child in children)
        {
            foreach (var leaf in GetLeafNodes(child))
                yield return leaf;
        }
    }

    private bool IsPathIgnored(string relativePath)
    {
        var norm = NormalizeRulePath(relativePath);
        return _fileRulesIgnore.Any(r =>
            norm.Equals(r, StringComparison.OrdinalIgnoreCase) ||
            norm.StartsWith(r + "/", StringComparison.OrdinalIgnoreCase));
    }

    private void ToggleNode(FileNode? node)
    {
        if (node == null) return;
        
        var current = GetNodeState(node);
        var next = current == FileRuleState.Ignore ? FileRuleState.Overwrite : FileRuleState.Ignore;

        if (node.IsDirectory)
        {
            ApplyDirectoryState(node, next);
        }
        else
        {
            var rel = NormalizeRulePath(node.RelativePath);
            if (next == FileRuleState.Ignore)
                _fileRulesIgnore.Add(rel);
            else
                _fileRulesIgnore.Remove(rel);
        }

        StateHasChanged();
    }

    private void ApplyDirectoryState(FileNode? node, FileRuleState state)
    {
        if (node == null) return;
        
        foreach (var path in EnumeratePaths(node).ToList())
        {
            _fileRulesIgnore.Remove(path);
        }

        if (state == FileRuleState.Ignore && !string.IsNullOrEmpty(node.RelativePath))
        {
            _fileRulesIgnore.Add(NormalizeRulePath(node.RelativePath));
        }
    }

    private IEnumerable<string> EnumeratePaths(FileNode? node)
    {
        if (node == null) yield break;
        
        if (!string.IsNullOrEmpty(node.RelativePath))
            yield return NormalizeRulePath(node.RelativePath);

        var children = node.Children;
        if (children == null) yield break;
        
        foreach (var child in children)
        {
            foreach (var p in EnumeratePaths(child))
                yield return p;
        }
    }

    private List<(FileNode Node, int Depth)> GetFlattenedTree()
    {
        var result = new List<(FileNode, int)>();
        if (_fileTreeRoot?.Children == null) return result;
        
        void Flatten(FileNode node, int depth)
        {
            if (node == null) return;
            result.Add((node, depth));
            
            var children = node.Children;
            if (children != null)
            {
                foreach (var child in children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
                {
                    Flatten(child, depth + 1);
                }
            }
        }
        
        foreach (var child in _fileTreeRoot.Children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
        {
            Flatten(child, 0);
        }
        
        return result;
    }

    #endregion

    // Delete Mod
    private async Task DeleteMod(ModEntry mod)
    {
        if (mod.Status == ModStatus.Pending)
        {
            // Not yet installed - just remove from config
            var result = await DialogService.ShowMessageBox(
                "Remove Mod",
                $"Remove '{mod.ModName}' from the mod list? (It hasn't been installed yet)",
                yesText: "Remove", cancelText: "Cancel");

            if (result == true)
            {
                await ConfigService.RemovePendingModAsync(mod.DownloadUrl);
                Snackbar.Add($"Mod '{mod.ModName}' removed.", Severity.Warning);
                StateHasChanged();
            }
        }
        else
        {
            // Installed - mark for removal
            var result = await DialogService.ShowMessageBox(
                "Uninstall Mod",
                $"Mark '{mod.ModName}' for uninstallation? Files will be removed when you click 'Apply Changes'.",
                yesText: "Uninstall", cancelText: "Cancel");

            if (result == true)
            {
                await ConfigService.MarkModForRemovalAsync(mod.DownloadUrl);
                Snackbar.Add($"Mod '{mod.ModName}' marked for removal. Click 'Apply Changes' to uninstall.", Severity.Warning);
                StateHasChanged();
            }
        }
    }

    // Utility Methods
    private string TruncateUrl(string url)
    {
        if (url.Length <= 50) return url;
        return url.Substring(0, 25) + "..." + url.Substring(url.Length - 22);
    }

    private string FormatTimestamp(string timestamp)
    {
        if (DateTime.TryParse(timestamp, out var dt))
        {
            return dt.ToString("MMM dd, yyyy HH:mm");
        }
        return "Never";
    }

    private string GetModCardStyle(ModEntry mod)
    {
        var baseStyle = "background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; height: 100%;";
        
        return mod.Status switch
        {
            ModStatus.Pending => baseStyle + " border-left: 4px solid var(--accent-orange);",
            ModStatus.PendingRemoval => baseStyle + " border-left: 4px solid var(--accent-red); opacity: 0.7;",
            _ => baseStyle
        };
    }

    private string GetStatusChipStyle(ModStatus status)
    {
        return status switch
        {
            ModStatus.Installed => "background: var(--accent-green); color: #000;",
            ModStatus.Pending => "background: var(--accent-orange); color: #000;",
            ModStatus.PendingRemoval => "background: var(--accent-red); color: #fff;",
            _ => "background: var(--text-secondary); color: #000;"
        };
    }

    private string GetStatusText(ModStatus status)
    {
        return status switch
        {
            ModStatus.Installed => "Installed",
            ModStatus.Pending => "Pending Install",
            ModStatus.PendingRemoval => "Pending Removal",
            _ => "Unknown"
        };
    }
}
