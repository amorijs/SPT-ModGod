@page "/modgod"
@layout MainLayout

@using ModGod.Models
@using ModGod.Services
@using Color = MudBlazor.Color
@using System.Linq
@using Microsoft.JSInterop
@using System.Text.Json

@inject ConfigService ConfigService
@inject ModDownloadService ModDownloadService
@inject ModInstallService ModInstallService
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime JS

<MudContainer MaxWidth="MaxWidth.ExtraLarge">
    <!-- Header Section -->
    <MudPaper Class="pa-6 mb-4" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 12px; margin-top: 55px;">
        <div class="d-flex justify-space-between align-center">
            <div>
                <MudText Typo="Typo.h4" Style="color: var(--text-primary); font-weight: 700;">SPT Server Mod Manager</MudText>
                <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">
                    Add mods to be installed on your SPT server. Clients will automatically sync from the installed files on the server.
                </MudText>
            </div>
            <div class="d-flex gap-2">
                <MudTooltip Text="Reload config from disk (if edited externally)">
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh" 
                                   Color="Color.Default"
                                   OnClick="ReloadFromDisk"
                                   Disabled="@_isApplying" />
                </MudTooltip>
                @if (ConfigService.HasPendingChanges())
                {
                    <MudButton Variant="Variant.Outlined" 
                               StartIcon="@Icons.Material.Filled.Undo" 
                               Color="Color.Default"
                               Style="font-weight: 600;"
                               OnClick="DiscardChanges"
                               Disabled="@_isApplying">
                        Discard Changes
                    </MudButton>
                    <MudTooltip Text="@(AnyModsNeedConfiguration() ? "Configure all mods before applying" : "")" Disabled="@(!AnyModsNeedConfiguration())">
                        <MudButton Variant="Variant.Filled" 
                                   StartIcon="@Icons.Material.Filled.PlayArrow" 
                                   Color="Color.Success"
                                   Style="font-weight: 600;"
                                   OnClick="ApplyChanges"
                                   Disabled="@(_isApplying || AnyModsNeedConfiguration())">
                            @if (_isApplying)
                            {
                                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                <span>Applying...</span>
                            }
                            else if (AnyModsNeedConfiguration())
                            {
                                <span>Mods Need Config</span>
                            }
                            else
                            {
                                <span>Apply Changes</span>
                            }
                        </MudButton>
                    </MudTooltip>
                }
                <MudButton Variant="Variant.Filled" 
                           StartIcon="@Icons.Material.Filled.Add" 
                           Color="Color.Primary"
                           Style="background: var(--accent-cyan); color: #000; font-weight: 600;"
                           OnClick="OpenAddModsDialog">
                    Add Mods
                </MudButton>
            </div>
        </div>
        
        @if (ConfigService.HasPendingChanges())
        {
            <MudAlert Severity="Severity.Warning" Class="mt-4" Dense="true">
                You have unsaved changes. Click "Apply Changes" to install/remove mods.
                @{
                    var changes = ConfigService.CalculateStagedChanges();
                }
                @if (changes.ModsToInstall.Count > 0)
                {
                    <span class="ml-2">üì¶ @changes.ModsToInstall.Count to install</span>
                }
                @if (changes.ModsToRemove.Count > 0)
                {
                    <span class="ml-2">üóëÔ∏è @changes.ModsToRemove.Count to remove</span>
                }
                @if (changes.ModsToUpdate.Count > 0)
                {
                    <span class="ml-2">üîÑ @changes.ModsToUpdate.Count to update</span>
                }
            </MudAlert>
        }
    </MudPaper>

    <!-- Stats Bar (Clickable Filters) -->
    <div class="d-flex gap-3 mb-4" style="flex-wrap: wrap;">
        <MudPaper Class="pa-4 flex-grow-1" Style="@GetStatsCardStyle(null)" @onclick="() => ToggleStatusFilter(null)">
            <div class="d-flex align-center">
                <MudIcon Icon="@Icons.Material.Filled.Extension" Style="color: var(--accent-cyan);" Class="mr-3" Size="Size.Large"/>
                <div>
                    <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@ConfigService.StagedConfig.ModList.Count</MudText>
                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Total Mods</MudText>
                </div>
            </div>
        </MudPaper>
        <MudPaper Class="pa-4 flex-grow-1" Style="@(GetStatsCardStyle("Installed"))" @onclick="@(() => ToggleStatusFilter("Installed"))">
            <div class="d-flex align-center">
                <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Style="color: var(--accent-green);" Class="mr-3" Size="Size.Large"/>
                <div>
                    <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@GetInstalledModCount()</MudText>
                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Installed</MudText>
                </div>
            </div>
        </MudPaper>
        <MudPaper Class="pa-4 flex-grow-1" Style="@(GetStatsCardStyle("Pending"))" @onclick="@(() => ToggleStatusFilter("Pending"))">
            <div class="d-flex align-center">
                <MudIcon Icon="@Icons.Material.Filled.Pending" Style="color: var(--accent-orange);" Class="mr-3" Size="Size.Large"/>
                <div>
                    <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@GetPendingModCount()</MudText>
                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Pending Install</MudText>
                </div>
            </div>
        </MudPaper>
        <MudPaper Class="pa-4 flex-grow-1" Style="@(GetStatsCardStyle("PendingRemoval"))" @onclick="@(() => ToggleStatusFilter("PendingRemoval"))">
            <div class="d-flex align-center">
                <MudIcon Icon="@Icons.Material.Filled.Delete" Style="color: var(--accent-red);" Class="mr-3" Size="Size.Large"/>
                <div>
                    <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@GetPendingRemovalCount()</MudText>
                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Pending Uninstall</MudText>
                </div>
            </div>
        </MudPaper>
        <MudPaper Class="pa-4 flex-grow-1" Style="@(GetStatsCardStyle("Required"))" @onclick="@(() => ToggleStatusFilter("Required"))">
            <div class="d-flex align-center">
                <MudIcon Icon="@Icons.Material.Filled.Lock" Style="color: var(--accent-red);" Class="mr-3" Size="Size.Large"/>
                <div>
                    <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@ConfigService.StagedConfig.ModList.Count(m => !m.Optional)</MudText>
                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Required</MudText>
                </div>
            </div>
        </MudPaper>
        <MudPaper Class="pa-4 flex-grow-1" Style="@(GetStatsCardStyle("Optional"))" @onclick="@(() => ToggleStatusFilter("Optional"))">
            <div class="d-flex align-center">
                <MudIcon Icon="@Icons.Material.Filled.LockOpen" Style="color: var(--accent-green);" Class="mr-3" Size="Size.Large"/>
                <div>
                    <MudText Typo="Typo.h4" Style="color: var(--text-primary);">@ConfigService.StagedConfig.ModList.Count(m => m.Optional)</MudText>
                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Optional</MudText>
                </div>
            </div>
        </MudPaper>
    </div>

    <MudTabs ActivePanelIndex="@_activeTabIndex"
             ActivePanelIndexChanged="OnTabChanged"
             Class="mb-4">
        <MudTabPanel Text="Mods" class="mt-4">
            <!-- Search Bar -->
            <div class="d-flex align-center gap-2 mb-4">
                <MudTextField @bind-Value="_searchQuery"
                              Placeholder="Search mods..."
                              Variant="Variant.Outlined"
                              Adornment="Adornment.Start"
                              AdornmentIcon="@Icons.Material.Filled.Search"
                              Immediate="true"
                              Clearable="true"
                              Style="max-width: 400px; background: var(--card-bg);" />
                @if (_activeStatusFilter != null || !string.IsNullOrEmpty(_searchQuery))
                {
                    <MudButton Variant="Variant.Text" 
                               StartIcon="@Icons.Material.Filled.Clear"
                               OnClick="ClearFilters"
                               Style="color: var(--text-secondary);">
                        Clear Filters
                    </MudButton>
                }
            </div>
            
            <!-- Mod Cards -->
            @{
                var hasPendingRemoval = GetPendingRemovalCount() > 0;
            }

            @if (ConfigService.StagedConfig.ModList.Count == 0 && !hasPendingRemoval)
            {
                <MudPaper Class="pa-8 text-center" Style="background: var(--card-bg); border: 2px dashed var(--border-color); border-radius: 12px;">
                    <MudIcon Icon="@Icons.Material.Filled.Inventory2" Size="Size.Large" Style="color: var(--text-secondary); font-size: 4rem;" />
                    <MudText Typo="Typo.h6" Class="mt-4" Style="color: var(--text-secondary);">No mods configured yet</MudText>
                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">Click "Add Mods" to get started</MudText>
                </MudPaper>
            }
            else
            {
                // Apply search and status filters
                var filteredMods = GetFilteredMods();
                
                // Sort: Protected mods first (ModGod), then pending install, pending uninstall, then installed
                // Within each group: needs-config first, then alphabetically
                var pendingMods = filteredMods
                    .Where(m => IsModPendingInstall(m))
                    .OrderByDescending(m => m.IsProtected)
                    .ThenByDescending(m => ModNeedsConfiguration(m))
                    .ThenBy(m => m.ModName, StringComparer.OrdinalIgnoreCase)
                    .ToList();
                var removalMods = filteredMods
                    .Where(m => IsModPendingRemoval(m))
                    .OrderByDescending(m => m.IsProtected)
                    .ThenBy(m => m.ModName, StringComparer.OrdinalIgnoreCase)
                    .ToList();
                var installedMods = filteredMods
                    .Where(m => !IsModPendingInstall(m) && !IsModPendingRemoval(m))
                    .OrderByDescending(m => m.IsProtected)
                    .ThenBy(m => m.ModName, StringComparer.OrdinalIgnoreCase)
                    .ToList();
                
                @if (filteredMods.Count == 0)
                {
                    <MudPaper Class="pa-6 text-center" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                        <MudIcon Icon="@Icons.Material.Filled.SearchOff" Size="Size.Large" Style="color: var(--text-secondary);" />
                        <MudText Typo="Typo.body1" Class="mt-2" Style="color: var(--text-secondary);">No mods match your search or filter</MudText>
                    </MudPaper>
                }
                else
                {
                    if (pendingMods.Count > 0)
                    {
                        <MudText Typo="Typo.subtitle1" Class="mb-2 mt-2" Style="color: var(--accent-orange); font-weight: 600;">
                            <MudIcon Icon="@Icons.Material.Filled.Pending" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                            Pending (@pendingMods.Count)
                        </MudText>
                        <MudGrid Class="mb-4">
                            @foreach (var mod in pendingMods)
                            {
                                @RenderModCard(mod)
                            }
                        </MudGrid>
                    }
                    
                    if (removalMods.Count > 0)
                    {
                        <MudText Typo="Typo.subtitle1" Class="mb-2 mt-2" Style="color: var(--accent-red); font-weight: 600;">
                            <MudIcon Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                            Pending Uninstall (@removalMods.Count)
                        </MudText>
                        <MudGrid Class="mb-4">
                            @foreach (var mod in removalMods)
                            {
                                @RenderModCard(mod)
                            }
                        </MudGrid>
                    }
                    
                    if (installedMods.Count > 0)
                    {
                        <MudText Typo="Typo.subtitle1" Class="mb-2 mt-2" Style="color: var(--accent-green); font-weight: 600;">
                            <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                            Installed (@installedMods.Count)
                        </MudText>
                        <MudGrid>
                            @foreach (var mod in installedMods)
                            {
                                @RenderModCard(mod)
                            }
                        </MudGrid>
                    }
                }
            }
        </MudTabPanel>

        <MudTabPanel Text="Sync Exclusions" Class="mt-4">
            <!-- Default Exclusions Section -->
            <MudPaper Class="pa-4 mb-4" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                <div class="d-flex justify-space-between align-center mb-2">
                    <div>
                        <MudText Typo="Typo.h6" Style="color: var(--text-primary); font-weight: 600;">
                            <MudIcon Icon="@Icons.Material.Filled.FilterAlt" Class="mr-2" Style="vertical-align: middle;" />
                            Default Exclusion Patterns
                        </MudText>
                        <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">
                            Built-in patterns to exclude logs, cache, dev files, and common mod data from syncing.
                        </MudText>
                    </div>
                    <MudSwitch T="bool" 
                               Value="@_useDefaultExclusions" 
                               ValueChanged="OnUseDefaultExclusionsChanged"
                               Color="Color.Success"
                               Label="@(_useDefaultExclusions ? "Enabled" : "Disabled")" />
                </div>
                
                @if (_useDefaultExclusions)
                {
                    <MudExpansionPanels Class="mt-3">
                        <MudExpansionPanel Text="@($"View/Edit Default Patterns ({_defaultExclusionPatterns.Count} patterns)")" 
                                           Style="background: var(--secondary-bg);">
                            <MudText Typo="Typo.caption" Class="mb-2" Style="color: var(--text-secondary);">
                                Patterns support globs: <code>*</code> (any chars), <code>**</code> (any path), <code>?</code> (single char)
                            </MudText>
                            <MudTextField T="string"
                                          Value="@_defaultExclusionPatternsText"
                                          ValueChanged="OnDefaultExclusionPatternsChanged"
                                          Lines="12"
                                          Variant="Variant.Outlined"
                                          Placeholder="One pattern per line..."
                                          Style="font-family: monospace; font-size: 12px;"
                                          HelperText="Edit patterns above. Changes save automatically." />
                            <div class="d-flex gap-2 mt-2">
                                <MudButton Variant="Variant.Text" 
                                           Size="Size.Small"
                                           StartIcon="@Icons.Material.Filled.RestartAlt"
                                           OnClick="ResetDefaultExclusionsToBuiltIn">
                                    Reset to Built-in Defaults
                                </MudButton>
                            </div>
                        </MudExpansionPanel>
                    </MudExpansionPanels>
                }
            </MudPaper>
            
            <!-- File Tree Exclusions Section -->
            <MudPaper Class="pa-4" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                <MudText Typo="Typo.h6" Style="color: var(--text-primary); font-weight: 600;">
                    <MudIcon Icon="@Icons.Material.Filled.FolderOff" Class="mr-2" Style="vertical-align: middle;" />
                    File/Folder Exclusions
                </MudText>
                <MudText Typo="Typo.body2" Class="mb-3" Style="color: var(--text-secondary);">
                    Browse files under <code>BepInEx/plugins</code> and <code>SPT/user/mods</code> and uncheck items to exclude them.
                </MudText>

                <div class="d-flex gap-2 mb-3">
                    <MudButton Variant="Variant.Outlined"
                               StartIcon="@Icons.Material.Filled.Refresh"
                               Disabled="_syncExclusionsLoading"
                               OnClick="LoadSyncExclusionsTreeAsync">
                        Refresh
                    </MudButton>
                    <MudText Typo="Typo.caption" Style="color: var(--text-secondary); align-self: center;">
                        Changes are saved automatically. Click "Apply Changes" to commit.
                    </MudText>
                </div>

                @if (_syncExclusionsLoading)
                {
                    <div class="d-flex align-center mb-2">
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <MudText Typo="Typo.body2">Scanning mod folders...</MudText>
                    </div>
                }
                else if (!string.IsNullOrEmpty(_syncExclusionsError))
                {
                    <MudAlert Severity="Severity.Warning">@_syncExclusionsError</MudAlert>
                }
                else if (_syncTreeRoot != null && _syncTreeRoot.Children != null && _syncTreeRoot.Children.Any())
                {
                    <MudPaper Class="pa-3" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); max-height: 420px; overflow-y: auto;">
                        <div class="mb-2" style="font-size:13px; color: var(--text-secondary);">
                            ‚úì Checked = sync to client &nbsp;|&nbsp; ‚òê Unchecked = exclude
                        </div>
                        @foreach (var (node, depth) in GetSyncFlattenedTree())
                        {
                            var state = GetSyncNodeState(node);
                            var indent = depth * 18;
                            var capturedNode = node;
                            var isExpanded = node.IsDirectory && _syncExpandedDirs.Contains(node.RelativePath);
                            var hasChildren = node.IsDirectory && node.Children?.Count > 0;
                            <div class="d-flex align-center" style="padding-left:@(indent)px; margin-bottom:2px;">
                                @* Expand/collapse button for directories *@
                                @if (hasChildren)
                                {
                                    <MudIconButton Icon="@(isExpanded ? Icons.Material.Filled.Remove : Icons.Material.Filled.Add)"
                                                   Size="Size.Small"
                                                   Style="padding: 2px; min-width: 24px; color: var(--text-secondary);"
                                                   OnClick="() => ToggleSyncExpand(capturedNode)" />
                                }
                                else
                                {
                                    <div style="width: 28px;"></div>
                                }
                                @* Checkbox for sync state *@
                                @{
                                    var checkIcon = state switch
                                    {
                                        SyncNodeState.Included => Icons.Material.Filled.CheckBox,
                                        SyncNodeState.Excluded => Icons.Material.Filled.CheckBoxOutlineBlank,
                                        _ => Icons.Material.Filled.IndeterminateCheckBox
                                    };
                                    var iconColor = state switch
                                    {
                                        SyncNodeState.Included => "var(--accent-green)",
                                        SyncNodeState.Excluded => "var(--text-secondary)",
                                        _ => "var(--accent-orange)"
                                    };
                                }
                                <MudIconButton Icon="@checkIcon"
                                               Size="Size.Small"
                                               Style="@($"padding: 2px; min-width: 24px; color: {iconColor};")"
                                               OnClick="() => OnSyncNodeClick(capturedNode)" />
                                @* Directory/file name (click to expand/collapse for directories) *@
                                @if (node.IsDirectory && hasChildren)
                                {
                                    <span class="ml-1 mono" style="color: var(--text-primary); cursor: pointer;" @onclick="() => ToggleSyncExpand(capturedNode)">
                                        üìÅ @(node.Name)
                                    </span>
                                }
                                else
                                {
                                    <span class="ml-1 mono" style="color: var(--text-primary);">
                                        @(node.IsDirectory ? "üìÅ" : "üìÑ") @(node.Name)
                                    </span>
                                }
                            </div>
                        }
                    </MudPaper>
                }
                else
                {
                    <MudAlert Severity="Severity.Info">
                        No files found in the tracked directories. Install mods or refresh.
                    </MudAlert>
                }
            </MudPaper>
        </MudTabPanel>
    </MudTabs>
</MudContainer>

<!-- Add Mods Dialog (Bulk) -->
<MudDialog @bind-Visible="_addDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true, CloseOnEscapeKey = false, BackdropClick = false })">
    <TitleContent>
        <MudText Typo="Typo.h6" Style="color: var(--text-primary);">
            @if (_addDialogStep == AddDialogStep.Input)
            {
                <span>Add Mods</span>
            }
            else if (_addDialogStep == AddDialogStep.Downloading)
            {
                <span>Downloading Mods...</span>
            }
            else
            {
                <span>Results</span>
            }
        </MudText>
    </TitleContent>
    <DialogContent>
        @if (_addDialogStep == AddDialogStep.Input)
        {
            <MudTabs @bind-ActivePanelIndex="_addDialogTabIndex" Class="mb-4" Rounded="true" ApplyEffectsToContainer="true">
                <!-- Tab 1: From Forge -->
                <MudTabPanel Text="From Forge" Icon="@Icons.Material.Filled.Store">
                    <div class="pa-2">
                        @* API Key Section *@
                        <MudPaper Class="pa-3 mb-4" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                            <div class="d-flex align-center justify-space-between mb-2">
                                <MudText Typo="Typo.subtitle2" Style="color: var(--text-primary);">
                                    <MudIcon Icon="@Icons.Material.Filled.Key" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                                    Forge API Key
                                </MudText>
                                @if (_forgeHasApiKey && !_forgeApiKeyValidating)
                                {
                                    <MudChip T="string" Size="Size.Small" Style="background: var(--accent-green); color: #000;">
                                        <MudIcon Icon="@Icons.Material.Filled.Check" Size="Size.Small" Class="mr-1" /> Configured
                                    </MudChip>
                                }
                            </div>
                            
                            @if (!_forgeHasApiKey)
                            {
                                <MudText Typo="Typo.body2" Class="mb-3" Style="color: var(--text-secondary);">
                                    Enter your Forge API key to search mods directly from SP-Tarkov Forge.
                                </MudText>
                                
                                <div class="d-flex gap-2 align-end">
                                    <MudTextField @bind-Value="_forgeApiKeyInput"
                                                  Label="API Key"
                                                  Variant="Variant.Outlined"
                                                  InputType="InputType.Password"
                                                  Immediate="true"
                                                  Disabled="_forgeApiKeyValidating"
                                                  Style="flex: 1;"
                                                  HelperText="@(_forgeApiKeyError ?? "")"
                                                  Error="@(_forgeApiKeyError != null)" />
                                    <MudButton Variant="Variant.Filled"
                                               Color="Color.Primary"
                                               Disabled="@(string.IsNullOrWhiteSpace(_forgeApiKeyInput) || _forgeApiKeyValidating)"
                                               OnClick="ValidateForgeApiKey"
                                               Style="height: 56px;">
                                        @if (_forgeApiKeyValidating)
                                        {
                                            <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                        }
                                        else
                                        {
                                            <span>Validate</span>
                                        }
                                    </MudButton>
                                </div>
                                
                                <MudLink Href="https://forge.sp-tarkov.com/user/api-tokens" Target="_blank" Class="mt-2 d-block" Style="font-size: 0.85rem;">
                                    <MudIcon Icon="@Icons.Material.Filled.OpenInNew" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                                    Get your API key here
                                </MudLink>
                            }
                            else
                            {
                                <div class="d-flex justify-space-between align-center">
                                    <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">
                                        API key is saved. Search for a forge mod, or paste the mod page URL below.
                                    </MudText>
                                    <MudButton Variant="Variant.Text" 
                                               Size="Size.Small"
                                               StartIcon="@Icons.Material.Filled.Delete"
                                               OnClick="RemoveForgeApiKey"
                                               Style="color: var(--accent-red);">
                                        Remove Key
                                    </MudButton>
                                </div>
                            }
                        </MudPaper>
                        
                        @* Forge Search Input *@
                        @if (_forgeHasApiKey)
                        {
                            <div style="position: relative;">
                                <MudTextField @bind-Value="_forgeSearchInput"
                                              @bind-Value:after="OnForgeSearchInputChanged"
                                              Label="Search mods or paste URL"
                                              Variant="Variant.Outlined"
                                              Immediate="true"
                                              Disabled="@(_forgeModLoading || _forgeMod != null)"
                                              Placeholder="Type to search or paste a Forge URL..."
                                              Adornment="Adornment.End"
                                              AdornmentIcon="@(_forgeSearchLoading ? Icons.Material.Filled.HourglassEmpty : Icons.Material.Filled.Search)"
                                              OnKeyDown="OnForgeSearchKeyDown"
                                              Class="mb-2"
                                              @onfocus="OnForgeSearchFocus" />
                                
                                @* Search Results Dropdown *@
                                @if (_forgeShowSearchResults && _forgeSearchResults.Any() && _forgeMod == null)
                                {
                                    <MudPaper Elevation="8" Style="max-height: 350px; overflow-y: auto; background: var(--card-bg); border: 1px solid var(--border-color);">
                                        <MudList T="ForgeSearchResult" Dense="true" Class="py-0">
                                            @foreach (var result in _forgeSearchResults)
                                            {
                                                <MudListItem T="ForgeSearchResult" OnClick="@(() => OnForgeSearchResultSelected(result))" Style="cursor: pointer;">
                                                    <div class="d-flex gap-2 align-center py-1">
                                                        @if (!string.IsNullOrEmpty(result.Thumbnail))
                                                        {
                                                            <MudImage Src="@result.Thumbnail" Width="40" Height="40" ObjectFit="ObjectFit.Cover" Style="border-radius: 4px; flex-shrink: 0;" />
                                                        }
                                                        else
                                                        {
                                                            <div style="width: 40px; height: 40px; background: var(--secondary-bg); border-radius: 4px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                                                <MudIcon Icon="@Icons.Material.Filled.Extension" Size="Size.Small" Style="color: var(--text-secondary);" />
                                                            </div>
                                                        }
                                                        <div style="flex: 1; min-width: 0;">
                                                            <MudText Typo="Typo.body2" Style="color: var(--text-primary); font-weight: 500;">@result.Name</MudText>
                                                            @if (!string.IsNullOrEmpty(result.Teaser))
                                                            {
                                                                <MudText Typo="Typo.caption" Style="color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                                                    @result.Teaser
                                                                </MudText>
                                                            }
                                                        </div>
                                                        <MudText Typo="Typo.caption" Style="color: var(--text-secondary); flex-shrink: 0;">
                                                            @FormatDownloadCount(result.Downloads)
                                                        </MudText>
                                                    </div>
                                                </MudListItem>
                                            }
                                        </MudList>
                                    </MudPaper>
                                }
                            </div>
                            
                            @* Clear selection button when mod is selected *@
                            @if (_forgeMod != null && !_forgeModLoading)
                            {
                                <MudButton Variant="Variant.Text" 
                                           Color="Color.Secondary" 
                                           Size="Size.Small"
                                           StartIcon="@Icons.Material.Filled.ArrowBack"
                                           OnClick="ClearForgeSelection"
                                           Class="mb-3">
                                    Search for another mod
                                </MudButton>
                            }
                            
                            @if (_forgeModLoading)
                            {
                                <div class="d-flex justify-center pa-4">
                                    <MudProgressCircular Indeterminate="true" />
                                </div>
                            }
                            else if (_forgeModError != null)
                            {
                                <MudAlert Severity="Severity.Error" Class="mb-4">@_forgeModError</MudAlert>
                            }
                            else if (_forgeMod != null)
                            {
                                @* Mod Preview Card *@
                                <MudPaper Class="pa-4" Style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                                    <div class="d-flex gap-3">
                                        @if (!string.IsNullOrEmpty(_forgeMod.Thumbnail))
                                        {
                                            <MudImage Src="@_forgeMod.Thumbnail" Width="80" Height="80" ObjectFit="ObjectFit.Cover" Style="border-radius: 8px;" />
                                        }
                                        else
                                        {
                                            <div style="width: 80px; height: 80px; background: var(--secondary-bg); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                                                <MudIcon Icon="@Icons.Material.Filled.Extension" Size="Size.Large" Style="color: var(--text-secondary);" />
                                            </div>
                                        }
                                        <div style="flex: 1;">
                                            <div class="d-flex align-center gap-2">
                                                <MudText Typo="Typo.h6" Style="color: var(--text-primary);">@_forgeMod.Name</MudText>
                                                @if (!string.IsNullOrEmpty(_forgeMod.DetailUrl))
                                                {
                                                    <MudIconButton Icon="@Icons.Material.Filled.OpenInNew" 
                                                                   Size="Size.Small" 
                                                                   Href="@_forgeMod.DetailUrl"
                                                                   Target="_blank"
                                                                   Style="color: var(--accent-cyan);" />
                                                }
                                            </div>
                                            <div class="d-flex gap-2 align-center mt-1">
                                                @if (!string.IsNullOrEmpty(_forgeMod.Owner))
                                                {
                                                    <MudText Typo="Typo.caption" Style="color: var(--text-secondary);">
                                                        by @_forgeMod.Owner
                                                    </MudText>
                                                }
                                                @if (!string.IsNullOrEmpty(_forgeMod.Category))
                                                {
                                                    <MudChip T="string" Size="Size.Small" Style="@GetForgeCategoryStyle(_forgeMod.CategoryColor)">
                                                        @_forgeMod.Category
                                                    </MudChip>
                                                }
                                            </div>
                                            @if (!string.IsNullOrEmpty(_forgeMod.Teaser))
                                            {
                                                <MudText Typo="Typo.body2" Class="mt-2" Style="color: var(--text-secondary);">
                                                    @_forgeMod.Teaser
                                                </MudText>
                                            }
                                            <MudText Typo="Typo.caption" Class="mt-1" Style="color: var(--text-secondary);">
                                                <MudIcon Icon="@Icons.Material.Filled.Download" Size="Size.Small" Style="vertical-align: middle;" />
                                                @FormatDownloadCount(_forgeMod.Downloads) downloads
                                            </MudText>
                                        </div>
                                    </div>
                                    
                                    <MudDivider Class="my-3" />
                                    
                                    @* Version Selector *@
                                    @if (_forgeMod.Versions.Any())
                                    {
                                        <MudSelect T="string" 
                                                   @bind-Value="_forgeSelectedVersion"
                                                   Label="Version"
                                                   Variant="Variant.Outlined"
                                                   Class="mb-3">
                                            @foreach (var version in _forgeMod.Versions)
                                            {
                                                <MudSelectItem T="string" Value="@version.Version">
                                                    <div class="d-flex justify-space-between align-center" style="width: 100%;">
                                                        <span>v@(version.Version)</span>
                                                        <span style="color: var(--text-secondary); font-size: 0.85rem;">
                                                            @(version.SptVersionConstraint ?? "Any SPT")
                                                        </span>
                                                    </div>
                                                </MudSelectItem>
                                            }
                                        </MudSelect>
                                        
                                        @if (_forgeMod.Versions.FirstOrDefault(v => v.Version == _forgeSelectedVersion) is { } selectedVer)
                                        {
                                            <MudText Typo="Typo.caption" Style="color: var(--text-secondary);">
                                                <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Style="vertical-align: middle;" />
                                                SPT Version: @(selectedVer.SptVersionConstraint ?? "Any") ‚Ä¢ 
                                                @FormatDownloadCount(selectedVer.Downloads) version downloads
                                            </MudText>
                                        }
                                    }
                                    else
                                    {
                                        <MudAlert Severity="Severity.Warning">No versions available for this mod.</MudAlert>
                                    }
                                    
                                    <MudCheckBox @bind-Value="_forgeOptional" 
                                                 Label="Mark as optional (not enforced on clients)"
                                                 Color="Color.Primary"
                                                 Class="mt-3" />
                                </MudPaper>
                            }
                        }
                    </div>
                </MudTabPanel>

                <!-- Tab 2: Direct URLs -->
                <MudTabPanel Text="Direct URLs" Icon="@Icons.Material.Filled.Link">
                    <div class="pa-2">
                        <MudPaper Class="pa-3 mb-4" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 8px;">
                            <MudText Typo="Typo.subtitle1" Style="color: var(--text-primary);">
                                <MudIcon Icon="@Icons.Material.Filled.Link" Size="Size.Small" Class="mr-1" />
                                Add Mods by Direct Download URL
                            </MudText>
                            <MudDivider Class="my-2" />
                            <MudText Typo="Typo.body2" Style="color: var(--text-secondary);">
                                Paste <b>direct download links</b> for mod archives.<br />
                                <span style="color:var(--accent-red)">Do <u>NOT</u> paste Forge mod page URLs here!</span> <br />
                                You can find your URL on GitHub/Forge/etc ‚Äì the link will usually end with <code>.zip</code>, <code>.7z</code> or similar.<br />
                                <span style="color: var(--text-secondary); font-size: 0.90em;">
                                    Mod name will be <span style="font-style: italic;">auto-detected from the file name.</span>
                                </span>
                                <MudAlert Severity="Severity.Info" Dense="true" Variant="Variant.Outlined" Class="mt-3">
                                    <b>Examples:</b><br />
                                    <span class="mono" style="display: block; color: var(--accent-green); margin-left: .5em;">
                                       https://github.com/example/mod/releases/download/v1.0/ModName.zip<br />
                                    </span>
                                    <b class="d-block mt-2" style="color: var(--accent-red);">Do NOT use:</b>
                                    <span class="mono" style="color: var(--accent-red); margin-left:.5em;">
                                        https://forge.sp-tarkov.com/mod/861/morecheckmarks
                                    </span>
                                </MudAlert>
                            </MudText>
                        </MudPaper>
                        
                        <MudTextField @bind-Value="_bulkUrls" 
                                      Label="Download URLs" 
                                      Variant="Variant.Outlined"
                                      Lines="8"
                                      Immediate="true"
                                      Placeholder="https://github.com/example/mod/releases/download/v1.0/ModName.zip&#10;https://github.com/another/mod.7z"
                                      Class="mb-4 mono" />
                        
                        <MudCheckBox @bind-Value="_bulkOptional" 
                                     Label="Mark all as optional (not enforced on clients)"
                                     Color="Color.Primary" />
                    </div>
                </MudTabPanel>
            </MudTabs>
        }
        else if (_addDialogStep == AddDialogStep.Downloading)
        {
            <div class="pa-4">
                <MudText Typo="Typo.body1" Class="mb-2" Style="color: var(--text-primary);">
                    Processing @(_currentDownloadIndex + 1) of @_urlsToProcess.Count
                </MudText>
                <MudProgressLinear Value="@((_currentDownloadIndex + 1) * 100.0 / _urlsToProcess.Count)" 
                                   Color="Color.Primary" 
                                   Rounded="true" 
                                   Size="Size.Large"
                                   Class="mb-4" />
                
                <MudText Typo="Typo.body2" Class="mono" Style="color: var(--text-secondary); word-break: break-all;">
                    @(_currentDownloadUrl ?? "Starting...")
                </MudText>
                
                @if (_downloadResults.Count > 0)
                {
                    <MudDivider Class="my-4" />
                    <MudText Typo="Typo.subtitle2" Class="mb-2" Style="color: var(--text-secondary);">
                        Status: @_downloadResults.Count(r => r.Success) succeeded, @_downloadResults.Count(r => !r.Success) failed
                    </MudText>
                }
            </div>
        }
        else if (_addDialogStep == AddDialogStep.Results)
        {
            <div class="pa-2">
                @{ 
                    var successes = _downloadResults.Where(r => r.Success).ToList();
                    var autoConfigured = successes.Where(r => r.SuggestedInstallPaths.Count > 0).ToList();
                    var needsConfig = successes.Where(r => r.SuggestedInstallPaths.Count == 0).ToList();
                    var failures = _downloadResults.Where(r => !r.Success).ToList();
                }
                
                @* Order: Errors ‚Üí Warnings ‚Üí Success *@
                
                @if (failures.Count > 0)
                {
                    <MudAlert Severity="Severity.Error" Class="mb-4">
                        Failed to download @failures.Count mod(s)
                    </MudAlert>
                    
                    <MudText Typo="Typo.subtitle2" Class="mb-2" Style="color: var(--accent-red);">
                        ‚úó Failed Downloads (@failures.Count)
                    </MudText>
                    <MudList T="string" Dense="true" Class="mb-4">
                        @foreach (var result in failures)
                        {
                            <MudListItem T="string" Icon="@Icons.Material.Filled.Error" IconColor="Color.Error">
                                <MudText Style="color: var(--text-primary); word-break: break-all; font-size: 0.85rem;">
                                    @TruncateUrl(result.Url)
                                </MudText>
                                <MudText Typo="Typo.caption" Style="color: var(--accent-red);">
                                    @result.Error
                                </MudText>
                            </MudListItem>
                        }
                    </MudList>
                }
                
                @if (needsConfig.Count > 0)
                {
                    <MudAlert Severity="Severity.Warning" Class="mb-4">
                        @needsConfig.Count mod(s) need manual install path configuration
                    </MudAlert>
                    
                    <MudText Typo="Typo.subtitle2" Class="mb-2" Style="color: var(--accent-orange);">
                        ‚ö† Needs Configuration (@needsConfig.Count)
                    </MudText>
                    <MudText Typo="Typo.caption" Class="mb-2" Style="color: var(--text-secondary);">
                        These mods don't have the standard folder structure (BepInEx/SPT). Click on them to configure install paths.
                    </MudText>
                    <MudList T="string" Dense="true" Class="mb-4">
                        @foreach (var result in needsConfig)
                        {
                            <MudListItem T="string" Icon="@Icons.Material.Filled.Settings" IconColor="Color.Warning">
                                <MudText Style="color: var(--text-primary);">@result.ModName</MudText>
                                <MudText Typo="Typo.caption" Style="color: var(--accent-orange);">
                                    Non-standard structure: @string.Join(", ", result.TopLevelDirectories.Take(3))@(result.TopLevelDirectories.Count > 3 ? "..." : "")
                                </MudText>
                            </MudListItem>
                        }
                    </MudList>
                }
                
                @if (successes.Count > 0)
                {
                    <MudAlert Severity="Severity.Success" Class="mb-4">
                        Successfully staged @successes.Count mod(s) for installation
                    </MudAlert>
                }
                
                @if (autoConfigured.Count > 0)
                {
                    <MudText Typo="Typo.subtitle2" Class="mb-2" Style="color: var(--accent-green);">
                        ‚úì Auto-Configured (@autoConfigured.Count)
                    </MudText>
                    <MudList T="string" Dense="true" Class="mb-4">
                        @foreach (var result in autoConfigured)
                        {
                            <MudListItem T="string" Icon="@Icons.Material.Filled.CheckCircle" IconColor="Color.Success">
                                <MudText Style="color: var(--text-primary);">@result.ModName</MudText>
                                <MudText Typo="Typo.caption" Style="color: var(--text-secondary);">
                                    @result.SuggestedInstallPaths.Count install path(s) detected
                                </MudText>
                            </MudListItem>
                        }
                    </MudList>
                }
            </div>
        }
    </DialogContent>
    <DialogActions>
        @if (_addDialogStep == AddDialogStep.Input)
        {
            <MudButton OnClick="CloseAddDialog" Variant="Variant.Text">Cancel</MudButton>
            @if (_addDialogTabIndex == 0)
            {
                @* Forge tab (Tab 0) *@
                <MudButton Color="Color.Primary" 
                           Variant="Variant.Filled"
                           Disabled="@(_forgeMod == null || string.IsNullOrEmpty(_forgeSelectedVersion))"
                           OnClick="ProcessForgeDownload">
                    Download & Stage
                </MudButton>
            }
            else
            {
                @* Direct URLs tab (Tab 1) *@
                <MudButton Color="Color.Primary" 
                           Variant="Variant.Filled"
                           Disabled="@(string.IsNullOrWhiteSpace(_bulkUrls))"
                           OnClick="ProcessBulkDownload">
                    Download & Stage
                </MudButton>
            }
        }
        else if (_addDialogStep == AddDialogStep.Downloading)
        {
            <MudText Typo="Typo.caption" Style="color: var(--text-secondary);">
                Please wait...
            </MudText>
        }
        else if (_addDialogStep == AddDialogStep.Results)
        {
            <MudButton Color="Color.Primary" 
                       Variant="Variant.Filled"
                       OnClick="CloseAddDialog">
                Done
            </MudButton>
        }
    </DialogActions>
</MudDialog>

<!-- Edit Mod Dialog -->
<MudDialog @bind-Visible="_editDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true })">
        <TitleContent>
            <MudText Typo="Typo.h6" Style="color: var(--text-primary);">Edit Mod</MudText>
        </TitleContent>
        <DialogContent>
            <MudTextField @bind-Value="_editModName" 
                          Label="Mod Name (For your reference only)" 
                          Variant="Variant.Outlined"
                          Class="mb-4"
                          Required="true" />
            
            <MudTextField Value="@_editDownloadUrl" 
                          Label="Download URL" 
                          Variant="Variant.Outlined"
                          Class="mb-4 mono"
                          ReadOnly="true"
                          HelperText="URL cannot be changed. Delete and re-add to update / use a different URL." />
            
            <MudCheckBox @bind-Value="_editIsOptional" 
                         Label="Optional mod (not enforced on clients)"
                         Color="Color.Primary"
                         Class="mb-4" />

            @* Archive Contents Viewer *@
            @if (_archiveContents != null && _archiveContents.Count > 0)
            {
                <MudExpansionPanels Class="mb-4">
                    <MudExpansionPanel Text="üì¶ Archive Contents" Style="background: var(--secondary-bg); border: 1px solid var(--border-color);">
                        <MudText Typo="Typo.caption" Class="mb-2" Style="color: var(--text-secondary);">
                            Use these paths to configure the install paths below. Top-level directories are shown first.
                        </MudText>
                        <MudPaper Class="pa-2" Style="background: var(--card-bg); max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                            @foreach (var item in _archiveContents)
                            {
                                var isDir = item.StartsWith("[DIR]");
                                var displayText = isDir ? item.Substring(6) : item;
                                var icon = isDir ? "üìÅ" : "üìÑ";
                                var indent = displayText.Count(c => c == '/') * 12;
                                <div style="padding-left: @(indent)px; color: @(isDir ? "var(--accent-cyan)" : "var(--text-primary)");">
                                    @icon @displayText
                                </div>
                            }
                        </MudPaper>
                    </MudExpansionPanel>
                </MudExpansionPanels>
            }

            <MudText Typo="Typo.subtitle1" Class="mt-4 mb-2" Style="color: var(--text-primary); font-weight: 600;">
                Install Paths
            </MudText>
            
            @if (_editInstallPaths != null)
            {
                @for (int i = 0; i < _editInstallPaths.Count; i++)
                {
                    var index = i;
                    <MudPaper Class="pa-3 mb-2" Style="background: var(--secondary-bg); border: 1px solid var(--border-color);">
                        <MudGrid>
                            <MudItem xs="5">
                                <MudTextField @bind-Value="_editInstallPaths[index].Source" 
                                              Label="Source Path" 
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Class="mono" />
                            </MudItem>
                            <MudItem xs="1" Class="d-flex align-center justify-center">
                                <MudIcon Icon="@Icons.Material.Filled.ArrowForward" />
                            </MudItem>
                            <MudItem xs="5">
                                <MudTextField @bind-Value="_editInstallPaths[index].Target" 
                                              Label="Target Path" 
                                              Variant="Variant.Outlined"
                                              Margin="Margin.Dense"
                                              Class="mono" />
                            </MudItem>
                            <MudItem xs="1" Class="d-flex align-center justify-center">
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                               Color="Color.Error" 
                                               Size="Size.Small"
                                               OnClick="@(() => RemoveEditInstallPath(index))" />
                            </MudItem>
                        </MudGrid>
                    </MudPaper>
                }
            }

            <MudButton Variant="Variant.Text" 
                       StartIcon="@Icons.Material.Filled.Add" 
                       Color="Color.Primary"
                       OnClick="AddEditInstallPath"
                       Class="mt-2">
                Add Install Path
            </MudButton>

            <MudDivider Class="my-4" />

            <MudText Typo="Typo.subtitle1" Class="mb-1" Style="color: var(--text-primary); font-weight: 600;">
                Files to be Overwritten
            </MudText>
            <MudText Typo="Typo.caption" Class="mb-3" Style="color: var(--text-secondary);">
                Any files <b>that will be overwritten</b> will appear below.
                <br />
                <span>
                    <b>Uncheck</b> any files you <b>do not want to overwrite</b>.
                </span>
                <br />
                <span style="color: var(--accent-orange);">
                    <i>
                        Example: Updating a server mod but want to keep your existing <code>config.json</code>? Simply uncheck that item.
                    </i>
                </span>
            </MudText>

            @if (_fileRulesLoading)
            {
                <div class="d-flex align-center mb-3">
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <MudText Typo="Typo.body2">Loading file tree...</MudText>
                </div>
            }
            else if (!string.IsNullOrEmpty(_fileRulesError))
            {
                <MudAlert Severity="Severity.Warning" Class="mb-3">
                    @_fileRulesError
                </MudAlert>
            }
            else if (_fileTreeRoot != null && _fileTreeRoot.Children != null && _fileTreeRoot.Children.Any())
            {
                <MudPaper Class="pa-3" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); max-height: 360px; overflow-y: auto;">
                    <div class="mb-2" style="font-size:13px; color: var(--text-secondary);">
                        ‚úì Checked = overwrite (default) &nbsp;|&nbsp; ‚òê Unchecked = ignore (keep existing)
                    </div>
                    @foreach (var item in GetFlattenedTree())
                    {
                        var node = item.Node;
                        var depth = item.Depth;
                        var state = GetNodeState(node);
                        var capturedNode = node;
                        var isExpanded = node.IsDirectory && _fileRulesExpandedDirs.Contains(node.RelativePath);
                        var hasChildren = node.IsDirectory && node.Children?.Count > 0;
                        <div class="d-flex align-center" style="padding-left:@(depth * 18)px; margin-bottom:2px;">
                            @* Expand/collapse button for directories *@
                            @if (hasChildren)
                            {
                                <MudIconButton Icon="@(isExpanded ? Icons.Material.Filled.Remove : Icons.Material.Filled.Add)"
                                               Size="Size.Small"
                                               Style="padding: 2px; min-width: 24px; color: var(--text-secondary);"
                                               OnClick="() => ToggleFileRulesExpand(capturedNode)" />
                            }
                            else
                            {
                                <div style="width: 28px;"></div>
                            }
                            @* Checkbox for state *@
                            @{
                                var checkIcon = state switch
                                {
                                    FileRuleState.Overwrite => Icons.Material.Filled.CheckBox,
                                    FileRuleState.Ignore => Icons.Material.Filled.CheckBoxOutlineBlank,
                                    _ => Icons.Material.Filled.IndeterminateCheckBox
                                };
                                var iconColor = state switch
                                {
                                    FileRuleState.Overwrite => "var(--accent-green)",
                                    FileRuleState.Ignore => "var(--text-secondary)",
                                    _ => "var(--accent-orange)"
                                };
                            }
                            <MudIconButton Icon="@checkIcon"
                                           Size="Size.Small"
                                           Style="@($"padding: 2px; min-width: 24px; color: {iconColor};")"
                                           OnClick="() => ToggleNode(capturedNode)" />
                            @* Directory/file name (click to expand/collapse for directories) *@
                            @if (node.IsDirectory && hasChildren)
                            {
                                <span class="ml-1 mono" style="color: var(--text-primary); cursor: pointer;" @onclick="() => ToggleFileRulesExpand(capturedNode)">
                                    üìÅ @(node.Name)
                                </span>
                            }
                            else
                            {
                                <span class="ml-1 mono" style="color: var(--text-primary);">
                                    @(node.IsDirectory ? "üìÅ" : "üìÑ") @(node.Name)
                                </span>
                            }
                        </div>
                    }
                </MudPaper>
            }
            else
            {
                <MudAlert Severity="Severity.Info">
                    No files found in staging for this mod. Reinstall to refresh the file list.
                </MudAlert>
            }
        </DialogContent>
        <DialogActions>
            <MudButton OnClick="CloseEditDialog" Variant="Variant.Text">Cancel</MudButton>
            <MudButton Color="Color.Primary" 
                       Variant="Variant.Filled"
                       Disabled="@(string.IsNullOrWhiteSpace(_editModName) || (_editInstallPaths?.Count ?? 0) == 0)"
                       OnClick="SaveEditMod">
                Save Changes
            </MudButton>
        </DialogActions>
</MudDialog>

<!-- Uninstall Mod Dialog -->
<MudDialog @bind-Visible="_uninstallDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6" Style="color: var(--text-primary);">
            Uninstall @(_uninstallMod?.ModName)
        </MudText>
    </TitleContent>
    <DialogContent>
        <MudText Typo="Typo.body2" Class="mb-2" Style="color: var(--text-secondary);">
            The selected paths will be queued for deletion when you click "Apply Changes".
        </MudText>

        <MudDivider Class="my-3" Style="border-color: var(--border-color);" />

        <MudText Typo="Typo.subtitle1" Class="mb-1" Style="color: var(--text-primary); font-weight: 600;">
            Paths to be deleted
        </MudText>
        <MudText Typo="Typo.caption" Class="mb-3" Style="color: var(--text-secondary);">
            ‚úì Checked = delete &nbsp;|&nbsp; ‚òê Unchecked = keep
        </MudText>

        @if (_uninstallTreeLoading)
        {
            <div class="d-flex align-center mb-2">
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <MudText Typo="Typo.body2">Loading paths...</MudText>
            </div>
        }
        else if (!string.IsNullOrEmpty(_uninstallTreeError))
        {
            <MudAlert Severity="Severity.Warning" Class="mb-2">
                @_uninstallTreeError
            </MudAlert>
        }
        else if (_uninstallTreeRoot != null && _uninstallTreeRoot.Children != null && _uninstallTreeRoot.Children.Any())
        {
            @if (_uninstallNoAutoPaths)
            {
                <MudAlert Severity="Severity.Warning" Class="mb-2">
                    No removal paths auto-detected. Check any files or folders you want removed, or delete them manually in your server files after clicking Apply Changes.
                </MudAlert>
            }

            <MudPaper Class="pa-3" Style="background: var(--secondary-bg); border: 1px solid var(--border-color); max-height: 360px; overflow-y: auto;">
                @foreach (var (node, depth) in GetUninstallFlattenedTree())
                {
                    var state = GetUninstallNodeState(node);
                    var capturedNode = node;
                    var isExpanded = node.IsDirectory && _uninstallExpandedDirs.Contains(node.RelativePath);
                    var hasChildren = node.IsDirectory && node.Children?.Count > 0;
                    <div class="d-flex align-center" style="padding-left:@(depth * 18)px; margin-bottom:2px;">
                        @if (hasChildren)
                        {
                            <MudIconButton Icon="@(isExpanded ? Icons.Material.Filled.Remove : Icons.Material.Filled.Add)"
                                           Size="Size.Small"
                                           Style="padding: 2px; min-width: 24px; color: var(--text-secondary);"
                                           OnClick="() => ToggleUninstallExpand(capturedNode)" />
                        }
                        else
                        {
                            <div style="width: 28px;"></div>
                        }

                        @{
                            var checkIcon = state switch
                            {
                                DeleteNodeState.Delete => Icons.Material.Filled.CheckBox,
                                DeleteNodeState.Keep => Icons.Material.Filled.CheckBoxOutlineBlank,
                                _ => Icons.Material.Filled.IndeterminateCheckBox
                            };
                            var iconColor = state switch
                            {
                                DeleteNodeState.Delete => "var(--accent-red)",
                                DeleteNodeState.Keep => "var(--text-secondary)",
                                _ => "var(--accent-orange)"
                            };
                        }
                        <MudIconButton Icon="@checkIcon"
                                       Size="Size.Small"
                                       Style="@($"padding: 2px; min-width: 24px; color: {iconColor};")"
                                       OnClick="() => ToggleUninstallNode(capturedNode)" />

                        @if (node.IsDirectory && hasChildren)
                        {
                            <span class="ml-1 mono" style="color: var(--text-primary); cursor: pointer;" @onclick="() => ToggleUninstallExpand(capturedNode)">
                                üìÅ @(node.Name)
                            </span>
                        }
                        else
                        {
                            <span class="ml-1 mono" style="color: var(--text-primary);">
                                @(node.IsDirectory ? "üìÅ" : "üìÑ") @(node.Name)
                            </span>
                        }
                    </div>
                }
            </MudPaper>
        }
        else
        {
            <MudAlert Severity="Severity.Info">
                No paths detected. The mod will be removed from your list without deleting files.
            </MudAlert>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseUninstallDialog" Variant="Variant.Text">Cancel</MudButton>
        <MudButton Color="Color.Error"
                   Variant="Variant.Filled"
                   Disabled="_uninstallTreeLoading"
                   OnClick="ConfirmUninstallSelection">
            Uninstall
        </MudButton>
    </DialogActions>
</MudDialog>

<!-- Apply Changes Result Dialog -->
<MudDialog @bind-Visible="_applyResultDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6" Style="color: var(--text-primary);">Apply Changes Result</MudText>
    </TitleContent>
    <DialogContent>
        @if (_applyResult != null)
        {
            @if (_applyResult.InstalledMods.Count > 0)
            {
                <MudAlert Severity="Severity.Success" Class="mb-3">
                    <MudText Typo="Typo.subtitle2">‚úì Installed @_applyResult.InstalledMods.Count mod(s):</MudText>
                    @foreach (var mod in _applyResult.InstalledMods)
                    {
                        <MudText Typo="Typo.body2" Class="ml-3">‚Ä¢ @mod</MudText>
                    }
                </MudAlert>
            }
            
            @if (_applyResult.QueuedForInstall.Count > 0)
            {
                <MudAlert Severity="Severity.Info" Class="mb-3">
                    <MudText Typo="Typo.subtitle2">üì¶ @_applyResult.QueuedForInstall.Count mod(s) will be installed on server restart:</MudText>
                    @foreach (var mod in _applyResult.QueuedForInstall)
                    {
                        <MudText Typo="Typo.body2" Class="ml-3">‚Ä¢ @mod</MudText>
                    }
                </MudAlert>
            }
            
            @if (_applyResult.QueuedForRemoval.Count > 0)
            {
                <MudAlert Severity="Severity.Info" Class="mb-3">
                    <MudText Typo="Typo.subtitle2">üóëÔ∏è @_applyResult.QueuedForRemoval.Count mod(s) will be removed on server restart:</MudText>
                    @foreach (var mod in _applyResult.QueuedForRemoval)
                    {
                        <MudText Typo="Typo.body2" Class="ml-3">‚Ä¢ @mod</MudText>
                    }
                </MudAlert>
            }
            
            @if (_applyResult.Errors.Count > 0)
            {
                <MudAlert Severity="Severity.Error" Class="mb-3">
                    <MudText Typo="Typo.subtitle2">‚ùå Errors:</MudText>
                    @foreach (var error in _applyResult.Errors)
                    {
                        <MudText Typo="Typo.body2" Class="ml-3">‚Ä¢ @error</MudText>
                    }
                </MudAlert>
            }
            
            @if (_applyResult.AutoInstallerLaunched)
            {
                <MudAlert Severity="Severity.Success" Class="mt-4">
                    <MudText Typo="Typo.subtitle2">üöÄ Auto-Installer Launched!</MudText>
                    <MudText Typo="Typo.body2" Class="mt-2">
                        A PowerShell window has opened that will automatically install the pending mods
                        when you stop the SPT server.
                    </MudText>
                    <MudText Typo="Typo.body2" Class="mt-2">
                        <strong>Just stop the server normally</strong> - the installer will detect it and complete the installation.
                    </MudText>
                </MudAlert>
            }
            else if (_applyResult.QueuedForInstall.Count > 0)
            {
                <MudAlert Severity="Severity.Info" Class="mt-4">
                    <MudText Typo="Typo.body2">
                        @(_applyResult.QueuedForInstall.Count) mod(s) queued for installation on next server restart.
                    </MudText>
                </MudAlert>
            }
        }
    </DialogContent>
    <DialogActions>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="@(() => _applyResultDialogVisible = false)">
            OK
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    private bool _hasLoggedInit = false;
    private int _activeTabIndex = 0;
    
    // Search and filter
    private string _searchQuery = "";
    private string? _activeStatusFilter = null; // null = show all, "Installed", "Pending", "Required"
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_hasLoggedInit)
        {
            _hasLoggedInit = true;
            await JS.InvokeVoidAsync("console.log", "[ModGod] Frontend loaded!");
        }
    }

    private RenderFragment RenderModCard(ModEntry mod) => __builder =>
    {
        <MudItem xs="12" md="6" lg="4">
            <MudPaper Class="pa-4" Style="@(GetModCardStyle(mod) + (mod.IsProtected ? "" : " cursor: pointer;"))" @onclick="() => { if (!mod.IsProtected) { if (IsModPendingRemoval(mod)) OpenUninstallDialog(mod); else EditMod(mod); } }">
                <div class="d-flex justify-space-between align-start mb-3">
                    <div>
                        <MudText Typo="Typo.h6" Style="color: var(--text-primary); font-weight: 600;">@mod.ModName</MudText>
                        <div class="d-flex gap-1 flex-wrap mt-1" @onclick:stopPropagation="true">
                            <MudChip T="string" Size="Size.Small" Style="@GetStatusChipStyleForMod(mod)">
                                @GetStatusTextForMod(mod)
                            </MudChip>
                            @if (mod.IsProtected)
                            {
                                <MudChip T="string" Size="Size.Small" 
                                         Style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff;">
                                    <MudIcon Icon="@Icons.Material.Filled.Shield" Size="Size.Small" Class="mr-1" /> Built-in
                                </MudChip>
                            }
                            else
                            {
                                <MudChip T="string" Size="Size.Small" 
                                         Style="@(mod.Optional ? "background: var(--accent-green); color: #000; cursor: pointer;" : "background: var(--accent-orange); color: #000; cursor: pointer;")"
                                         OnClick="@(() => ToggleModOptional(mod))">
                                    @(mod.Optional ? "Optional" : "Required")
                                </MudChip>
                            }
                        </div>
                    </div>
                    @if (!mod.IsProtected)
                    {
                        <div @onclick:stopPropagation="true">
                            <MudMenu Icon="@Icons.Material.Filled.MoreVert" Dense="true">
                                @if (IsModPendingRemoval(mod))
                                {
                                    <MudMenuItem OnClick="@(() => OpenUninstallDialog(mod))">
                                        <MudIcon Icon="@Icons.Material.Filled.Edit" Size="Size.Small" Class="mr-2" /> Edit Removal
                                    </MudMenuItem>
                                    <MudMenuItem OnClick="@(() => UndoRemoval(mod))" Style="color: var(--accent-green);">
                                        <MudIcon Icon="@Icons.Material.Filled.Undo" Size="Size.Small" Class="mr-2" /> Undo Removal
                                    </MudMenuItem>
                                }
                                else
                                {
                                    <MudMenuItem OnClick="@(() => EditMod(mod))">
                                        <MudIcon Icon="@Icons.Material.Filled.Edit" Size="Size.Small" Class="mr-2" /> Edit
                                    </MudMenuItem>
                                    @if (mod.Status == ModStatus.Installed)
                                    {
                                        <MudTooltip Text="Re-download and re-install this mod from the original URL. Useful if mod files were corrupted or manually modified.">
                                            <MudMenuItem OnClick="@(() => ReinstallMod(mod))">
                                                <MudIcon Icon="@Icons.Material.Filled.Refresh" Size="Size.Small" Class="mr-2" /> Reinstall
                                            </MudMenuItem>
                                        </MudTooltip>
                                    }
                                    <MudMenuItem OnClick="@(() => DeleteMod(mod))" Style="color: var(--accent-red);">
                                        <MudIcon Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Class="mr-2" /> 
                                        @(IsModPendingInstall(mod) ? "Remove" : "Uninstall")
                                    </MudMenuItem>
                                }
                            </MudMenu>
                        </div>
                    }
                </div>

                <MudText Typo="Typo.body2" Class="mono mb-2" Style="color: var(--text-secondary); word-break: break-all; font-size: 0.75rem;">
                    @TruncateUrl(mod.DownloadUrl)
                </MudText>

                <MudDivider Class="my-3" Style="border-color: var(--border-color);" />

                <MudText Typo="Typo.caption" Style="color: var(--text-secondary);">
                    <MudIcon Icon="@Icons.Material.Filled.Schedule" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                    Updated: @FormatTimestamp(mod.LastUpdated)
                </MudText>

                <MudText Typo="Typo.caption" Class="mt-1 d-block" Style="color: var(--text-secondary);">
                    <MudIcon Icon="@Icons.Material.Filled.Folder" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                    @mod.InstallPaths.Count install path(s)
                </MudText>
                
                @if (IsModPendingInstall(mod))
                {
                    @if (ModNeedsConfiguration(mod))
                    {
                        <div class="mt-2 pa-2" style="background: rgba(255, 82, 82, 0.15); border: 1px solid var(--accent-red); border-radius: 6px;">
                            <MudText Typo="Typo.caption" Style="color: var(--accent-red);">
                                <MudIcon Icon="@Icons.Material.Filled.Build" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                                Needs configuration ‚Äî click to set install paths
                            </MudText>
                        </div>
                    }
                    else
                    {
                        var (overwriteCount, skippedCount) = GetOverwriteStatsForMod(mod);
                        
                        @if (overwriteCount > 0)
                        {
                            <div class="mt-2 pa-2" style="background: rgba(210, 153, 34, 0.15); border: 1px solid var(--accent-orange); border-radius: 6px;">
                                <MudText Typo="Typo.caption" Style="color: var(--accent-orange);">
                                    <MudIcon Icon="@Icons.Material.Filled.Warning" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                                    @overwriteCount existing file(s) will be overwritten
                                </MudText>
                            </div>
                        }
                        
                        @if (skippedCount > 0)
                        {
                            <div class="@(overwriteCount > 0 ? "mt-1" : "mt-2") pa-2" style="background: rgba(88, 166, 255, 0.1); border: 1px solid var(--accent-cyan); border-radius: 6px;">
                                <MudText Typo="Typo.caption" Style="color: var(--accent-cyan);">
                                    <MudIcon Icon="@Icons.Material.Filled.Shield" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                                    @skippedCount file(s) preserved (won't overwrite)
                                </MudText>
                            </div>
                        }
                    }
                }
            </MudPaper>
        </MudItem>
    };

    private async Task ToggleModOptional(ModEntry mod)
    {
        mod.Optional = !mod.Optional;
        await ConfigService.SaveStagedConfigAsync();
        Snackbar.Add($"'{mod.ModName}' is now {(mod.Optional ? "optional" : "required")}", Severity.Info);
        StateHasChanged();
    }
    
    // State
    private bool _isApplying = false;
    private ApplyChangesResult? _applyResult;
    private bool _applyResultDialogVisible = false;

    // Add Mods Dialog (Bulk)
    private bool _addDialogVisible = false;
    private AddDialogStep _addDialogStep = AddDialogStep.Input;
    private int _addDialogTabIndex = 0; // 0 = Direct URLs, 1 = From Forge
    private string _bulkUrls = "";
    private bool _bulkOptional = false;
    private List<string> _urlsToProcess = new();
    private int _currentDownloadIndex = 0;
    private string? _currentDownloadUrl;
    private List<ModDownloadResult> _downloadResults = new();

    private enum AddDialogStep { Input, Downloading, Results }

    // Forge Integration
    private bool _forgeHasApiKey = false;
    private string _forgeApiKeyInput = "";
    private bool _forgeApiKeyValidating = false;
    private string? _forgeApiKeyError;
    private string _forgeSearchInput = "";
    private bool _forgeModLoading = false;
    private ForgeModInfo? _forgeMod = null;
    private string? _forgeModError;
    private string? _forgeSelectedVersion;
    private bool _forgeOptional = false;
    
    // Forge Search
    private List<ForgeSearchResult> _forgeSearchResults = new();
    private bool _forgeSearchLoading = false;
    private bool _forgeShowSearchResults = false;
    private System.Threading.Timer? _forgeSearchDebounceTimer;
    private const int ForgeSearchDebounceMs = 400;

    private class ForgeModInfo
    {
        public int Id { get; set; }
        public string Guid { get; set; } = "";
        public string Name { get; set; } = "";
        public string? Teaser { get; set; }
        public string? Thumbnail { get; set; }
        public long Downloads { get; set; }
        public string? Owner { get; set; }
        public string? Category { get; set; }
        public string? CategoryColor { get; set; }
        public string? License { get; set; }
        public string? DetailUrl { get; set; }
        public List<ForgeVersionInfo> Versions { get; set; } = new();
    }

    private class ForgeVersionInfo
    {
        public int Id { get; set; }
        public string Version { get; set; } = "";
        public string? SptVersionConstraint { get; set; }
        public long Downloads { get; set; }
        public string? PublishedAt { get; set; }
        public string DownloadUrl { get; set; } = "";
    }

    private class ForgeSearchResult
    {
        public int Id { get; set; }
        public string Name { get; set; } = "";
        public string Slug { get; set; } = "";
        public string? Thumbnail { get; set; }
        public long Downloads { get; set; }
        public string? Teaser { get; set; }
        public string? DetailUrl { get; set; }
    }

    // Edit Mod Dialog
    private bool _editDialogVisible = false;
    private ModEntry? _editingMod = null;
    private string _editModName = "";
    private string _editDownloadUrl = "";
    private bool _editIsOptional = false;
    private List<InstallPathItem> _editInstallPaths = new();
    private List<string>? _archiveContents;

    private class InstallPathItem
    {
        public string Source { get; set; } = "";
        public string Target { get; set; } = "";
    }

    // Sync exclusions (manifest opt-out)
    private bool _syncExclusionsLoading = false;
    private string? _syncExclusionsError;
    private bool _syncTabInitialized = false;
    private FileNode? _syncTreeRoot;
    private HashSet<string> _syncExclusionSet = new(StringComparer.OrdinalIgnoreCase);
    private HashSet<string> _syncExpandedDirs = new(StringComparer.OrdinalIgnoreCase);
    
    // Default exclusion patterns
    private bool _useDefaultExclusions = true;
    private List<string> _defaultExclusionPatterns = new();
    private string _defaultExclusionPatternsText = "";

    private enum SyncNodeState { Included, Excluded, Mixed }

    // File rules for install (overwrite/ignore)
    private enum FileRuleState { Overwrite, Ignore, Mixed }
    private HashSet<string> _fileRulesExpandedDirs = new(StringComparer.OrdinalIgnoreCase);

    private class FileNode
    {
        public string Name { get; set; } = "";
        public string RelativePath { get; set; } = "";
        public bool IsDirectory { get; set; }
        public List<FileNode> Children { get; set; } = new();
    }

    private FileNode? _fileTreeRoot;
    private HashSet<string> _fileRulesIgnore = new(StringComparer.OrdinalIgnoreCase);
    private bool _fileRulesLoading = false;
    private string? _fileRulesError;

    // Uninstall dialog state
    private bool _uninstallDialogVisible = false;
    private ModEntry? _uninstallMod = null;
    private FileNode? _uninstallTreeRoot;
    private HashSet<string> _uninstallCheckedPaths = new(StringComparer.OrdinalIgnoreCase);
    private HashSet<string> _uninstallExpandedDirs = new(StringComparer.OrdinalIgnoreCase);
    private bool _uninstallTreeLoading = false;
    private string? _uninstallTreeError;
    private bool _uninstallNoAutoPaths = false;

    private enum DeleteNodeState
    {
        Delete,
        Keep,
        Mixed
    }

    // Apply Changes
    private async Task ApplyChanges()
    {
        _isApplying = true;
        StateHasChanged();

        try
        {
            _applyResult = await ModInstallService.ApplyPendingChangesAsync();
            _applyResultDialogVisible = true;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error applying changes: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isApplying = false;
            StateHasChanged();
        }
    }
    
    // Discard Changes - reset staged config to match live config
    private async Task DiscardChanges()
    {
        var result = await DialogService.ShowMessageBox(
            "Discard Changes",
            "This will discard all unsaved changes and reset to the last applied state. Continue?",
            yesText: "Discard", cancelText: "Cancel");

        if (result == true)
        {
            await ConfigService.ResetStagedConfigAsync();
            Snackbar.Add("Changes discarded.", Severity.Info);
            StateHasChanged();
        }
    }
    
    // Reload config from disk (useful if edited externally)
    private async Task ReloadFromDisk()
    {
        await ConfigService.ReloadConfigFromDiskAsync();
        _syncTabInitialized = false; // Force sync tab to reload
        
        // Reset default exclusions state
        _useDefaultExclusions = ConfigService.StagedConfig.UseDefaultExclusions;
        _defaultExclusionPatterns = ConfigService.StagedConfig.CustomDefaultExclusions?.ToList() 
            ?? DefaultSyncExclusions.Patterns.ToList();
        _defaultExclusionPatternsText = string.Join("\n", _defaultExclusionPatterns);
        
        Snackbar.Add("Reloaded config from disk.", Severity.Info);
        StateHasChanged();
    }

    // Add Mods Dialog Methods
    private async Task OpenAddModsDialog()
    {
        _bulkUrls = "";
        _bulkOptional = false;
        _urlsToProcess = new();
        _downloadResults = new();
        _currentDownloadIndex = 0;
        _currentDownloadUrl = null;
        _addDialogStep = AddDialogStep.Input;
        _addDialogTabIndex = 0;
        
        // Reset Forge state
        _forgeApiKeyInput = "";
        _forgeApiKeyValidating = false;
        _forgeApiKeyError = null;
        _forgeSearchInput = "";
        _forgeModLoading = false;
        _forgeMod = null;
        _forgeModError = null;
        _forgeSelectedVersion = null;
        _forgeOptional = false;
        _forgeSearchResults.Clear();
        _forgeShowSearchResults = false;
        _forgeSearchDebounceTimer?.Dispose();
        
        // Check if Forge API key is already configured
        await CheckForgeApiKeyStatus();
        
        _addDialogVisible = true;
    }
    
    private async Task CheckForgeApiKeyStatus()
    {
        try
        {
            using var client = new HttpClient(new HttpClientHandler 
            { 
                ServerCertificateCustomValidationCallback = (_, _, _, _) => true 
            });
            var response = await client.GetAsync("https://127.0.0.1:6969/modgod/api/forge/status");
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                var result = System.Text.Json.JsonSerializer.Deserialize<ForgeStatusResponse>(json,
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                _forgeHasApiKey = result?.HasApiKey ?? false;
            }
        }
        catch
        {
            _forgeHasApiKey = false;
        }
    }
    
    private class ForgeStatusResponse
    {
        public bool HasApiKey { get; set; }
    }

    private async Task ProcessBulkDownload()
    {
        _urlsToProcess = _bulkUrls
            .Split(new[] { '\n', '\r', ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(u => u.Trim())
            .Where(u => !string.IsNullOrWhiteSpace(u) && (u.StartsWith("http://") || u.StartsWith("https://")))
            .Distinct()
            .ToList();

        if (_urlsToProcess.Count == 0)
        {
            Snackbar.Add("No valid URLs found. Please enter direct download links.", Severity.Warning);
            return;
        }

        _downloadResults = new();
        _currentDownloadIndex = 0;
        _addDialogStep = AddDialogStep.Downloading;
        await InvokeAsync(StateHasChanged);

        foreach (var url in _urlsToProcess)
        {
            _currentDownloadUrl = url;
            await InvokeAsync(StateHasChanged);

            try
            {
                var result = await ModDownloadService.DownloadAndAnalyzeModAsync(url);
                
                if (result.Success && string.IsNullOrWhiteSpace(result.ModName))
                {
                    result.ModName = ExtractModNameFromUrl(url);
                }

                _downloadResults.Add(result);

                if (result.Success)
                {
                    // For non-standard mods, generate install paths from top-level directories
                    var installPaths = result.SuggestedInstallPaths.Count > 0 
                        ? result.SuggestedInstallPaths 
                        : result.TopLevelDirectories.Count > 0
                            ? result.TopLevelDirectories.Select(dir => new[] { dir, $"<SPT_ROOT>/{dir}" }).ToList()
                            : new List<string[]> { new[] { "", "<SPT_ROOT>/" } };
                    
                    var mod = new ModEntry
                    {
                        ModName = result.ModName ?? ExtractModNameFromUrl(url),
                        DownloadUrl = url,
                        Optional = _bulkOptional,
                        LastUpdated = DateTime.UtcNow.ToString("o"),
                        InstallPaths = installPaths,
                        Status = ModStatus.Installed // Staged mods represent desired state
                    };
                    await ConfigService.AddModToStagedAsync(mod);
                }
            }
            catch (Exception ex)
            {
                _downloadResults.Add(new ModDownloadResult
                {
                    Url = url,
                    Success = false,
                    Error = ex.Message
                });
            }

            _currentDownloadIndex++;
            await InvokeAsync(StateHasChanged);
        }

        _addDialogStep = AddDialogStep.Results;
        await InvokeAsync(StateHasChanged);
    }

    private string ExtractModNameFromUrl(string url)
    {
        try
        {
            var uri = new Uri(url);
            var filename = Path.GetFileName(uri.LocalPath);
            
            var extensions = new[] { ".zip", ".7z", ".rar", ".tar.gz", ".tar", ".gz" };
            foreach (var ext in extensions)
            {
                if (filename.EndsWith(ext, StringComparison.OrdinalIgnoreCase))
                {
                    filename = filename.Substring(0, filename.Length - ext.Length);
                    break;
                }
            }
            
            return string.IsNullOrWhiteSpace(filename) ? "UnknownMod" : filename;
        }
        catch
        {
            return "UnknownMod";
        }
    }

    private void CloseAddDialog()
    {
        _addDialogVisible = false;
        _addDialogStep = AddDialogStep.Input;
        StateHasChanged();
    }

    // Forge Integration Methods
    private async Task ValidateForgeApiKey()
    {
        if (string.IsNullOrWhiteSpace(_forgeApiKeyInput))
            return;

        _forgeApiKeyValidating = true;
        _forgeApiKeyError = null;
        StateHasChanged();

        try
        {
            using var client = new HttpClient(new HttpClientHandler 
            { 
                ServerCertificateCustomValidationCallback = (_, _, _, _) => true 
            });
            
            var content = new StringContent(
                System.Text.Json.JsonSerializer.Serialize(new { apiKey = _forgeApiKeyInput }),
                System.Text.Encoding.UTF8,
                "application/json");
            
            var response = await client.PostAsync("https://127.0.0.1:6969/modgod/api/forge/validate-key", content);
            var json = await response.Content.ReadAsStringAsync();
            var result = System.Text.Json.JsonSerializer.Deserialize<ForgeValidateResponse>(json, 
                new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (result?.Success == true)
            {
                _forgeHasApiKey = true;
                Snackbar.Add("Forge API key validated and saved!", Severity.Success);
            }
            else
            {
                _forgeApiKeyError = result?.Error ?? "Failed to validate API key";
            }
        }
        catch (Exception ex)
        {
            _forgeApiKeyError = $"Connection error: {ex.Message}";
        }
        finally
        {
            _forgeApiKeyValidating = false;
            StateHasChanged();
        }
    }

    private class ForgeValidateResponse
    {
        public bool Success { get; set; }
        public string? Error { get; set; }
    }

    private async Task RemoveForgeApiKey()
    {
        try
        {
            using var client = new HttpClient(new HttpClientHandler 
            { 
                ServerCertificateCustomValidationCallback = (_, _, _, _) => true 
            });
            
            var response = await client.DeleteAsync("https://127.0.0.1:6969/modgod/api/forge/key");
            
            if (response.IsSuccessStatusCode)
            {
                _forgeHasApiKey = false;
                _forgeMod = null;
                _forgeSelectedVersion = null;
                _forgeSearchInput = "";
                _forgeSearchResults.Clear();
                _forgeShowSearchResults = false;
                Snackbar.Add("Forge API key removed", Severity.Info);
            }
            else
            {
                Snackbar.Add("Failed to remove API key", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        
        StateHasChanged();
    }

    private async Task OnForgeSearchKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && _forgeShowSearchResults && _forgeSearchResults.Any())
        {
            // Select first result on Enter
            await OnForgeSearchResultSelected(_forgeSearchResults.First());
        }
        else if (e.Key == "Escape")
        {
            _forgeShowSearchResults = false;
        }
    }

    private void OnForgeSearchFocus()
    {
        if (_forgeSearchResults.Any() && _forgeMod == null)
        {
            _forgeShowSearchResults = true;
        }
    }

    private void OnForgeSearchInputChanged()
    {
        if (string.IsNullOrWhiteSpace(_forgeSearchInput))
        {
            _forgeSearchResults.Clear();
            _forgeShowSearchResults = false;
            _forgeSearchDebounceTimer?.Dispose();
            return;
        }

        // Check if it's a Forge URL - if so, fetch directly
        var modId = ExtractModIdFromForgeUrl(_forgeSearchInput);
        if (modId != null)
        {
            _forgeSearchDebounceTimer?.Dispose();
            _ = FetchForgeModById(modId.Value);
            return;
        }

        // Otherwise, debounce and search
        _forgeSearchDebounceTimer?.Dispose();
        _forgeSearchDebounceTimer = new System.Threading.Timer(
            async _ => await InvokeAsync(ExecuteForgeSearch),
            null,
            ForgeSearchDebounceMs,
            Timeout.Infinite
        );
    }

    private async Task ExecuteForgeSearch()
    {
        if (string.IsNullOrWhiteSpace(_forgeSearchInput) || _forgeMod != null)
            return;

        _forgeSearchLoading = true;
        StateHasChanged();

        try
        {
            using var client = new HttpClient(new HttpClientHandler 
            { 
                ServerCertificateCustomValidationCallback = (_, _, _, _) => true 
            });
            
            var queryEncoded = Uri.EscapeDataString(_forgeSearchInput);
            var response = await client.GetAsync($"https://127.0.0.1:6969/modgod/api/forge/search?query={queryEncoded}");
            var json = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                var result = System.Text.Json.JsonSerializer.Deserialize<ForgeSearchApiResponse>(json, 
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });

                if (result?.Success == true && result.Mods != null)
                {
                    _forgeSearchResults = result.Mods.Select(m => new ForgeSearchResult
                    {
                        Id = m.Id,
                        Name = m.Name ?? "",
                        Slug = m.Slug ?? "",
                        Thumbnail = m.Thumbnail,
                        Downloads = m.Downloads,
                        Teaser = m.Teaser,
                        DetailUrl = m.DetailUrl
                    }).ToList();
                    _forgeShowSearchResults = _forgeSearchResults.Any();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Search error: {ex.Message}");
        }
        finally
        {
            _forgeSearchLoading = false;
            StateHasChanged();
        }
    }

    private async Task OnForgeSearchResultSelected(ForgeSearchResult result)
    {
        _forgeShowSearchResults = false;
        _forgeSearchResults.Clear();
        _forgeSearchInput = result.Name;
        await FetchForgeModById(result.Id);
    }

    private void ClearForgeSelection()
    {
        _forgeMod = null;
        _forgeSelectedVersion = null;
        _forgeModError = null;
        _forgeSearchInput = "";
        _forgeSearchResults.Clear();
        _forgeShowSearchResults = false;
    }

    private async Task FetchForgeModById(int modId)
    {

        _forgeModLoading = true;
        _forgeModError = null;
        _forgeMod = null;
        StateHasChanged();

        try
        {
            using var client = new HttpClient(new HttpClientHandler 
            { 
                ServerCertificateCustomValidationCallback = (_, _, _, _) => true 
            });
            
            var response = await client.GetAsync($"https://127.0.0.1:6969/modgod/api/forge/mod/{modId}");
            var json = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                var result = System.Text.Json.JsonSerializer.Deserialize<ForgeModApiResponse>(json, 
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });

                if (result?.Success == true && result.Mod != null)
                {
                    _forgeMod = new ForgeModInfo
                    {
                        Id = result.Mod.Id,
                        Guid = result.Mod.Guid ?? "",
                        Name = result.Mod.Name ?? "Unknown",
                        Teaser = result.Mod.Teaser,
                        Thumbnail = result.Mod.Thumbnail,
                        Downloads = result.Mod.Downloads,
                        Owner = result.Mod.Owner,
                        Category = result.Mod.Category,
                        CategoryColor = result.Mod.CategoryColor,
                        License = result.Mod.License,
                        DetailUrl = result.Mod.DetailUrl,
                        Versions = result.Mod.Versions?.Select(v => new ForgeVersionInfo
                        {
                            Id = v.Id,
                            Version = v.Version ?? "",
                            SptVersionConstraint = v.SptVersionConstraint,
                            Downloads = v.Downloads,
                            PublishedAt = v.PublishedAt,
                            DownloadUrl = v.DownloadUrl ?? ""
                        }).ToList() ?? new()
                    };

                    // Auto-select latest version
                    _forgeSelectedVersion = _forgeMod.Versions.FirstOrDefault()?.Version;
                }
                else
                {
                    _forgeModError = "Mod not found or API error";
                }
            }
            else
            {
                var errorResult = System.Text.Json.JsonSerializer.Deserialize<ForgeValidateResponse>(json,
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                _forgeModError = errorResult?.Error ?? $"API error: {response.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            _forgeModError = $"Error fetching mod details: {ex.Message}";
        }
        finally
        {
            _forgeModLoading = false;
            StateHasChanged();
        }
    }

    private class ForgeModApiResponse
    {
        public bool Success { get; set; }
        public ForgeModApiData? Mod { get; set; }
        public string? Error { get; set; }
    }

    private class ForgeSearchApiResponse
    {
        public bool Success { get; set; }
        public List<ForgeSearchModApiData>? Mods { get; set; }
        public string? Error { get; set; }
    }

    private class ForgeSearchModApiData
    {
        public int Id { get; set; }
        public string? Name { get; set; }
        public string? Slug { get; set; }
        public string? Thumbnail { get; set; }
        public long Downloads { get; set; }
        public string? Teaser { get; set; }
        public string? DetailUrl { get; set; }
    }

    private class ForgeModApiData
    {
        public int Id { get; set; }
        public string? Guid { get; set; }
        public string? Name { get; set; }
        public string? Teaser { get; set; }
        public string? Thumbnail { get; set; }
        public long Downloads { get; set; }
        public string? Owner { get; set; }
        public string? Category { get; set; }
        public string? CategoryColor { get; set; }
        public string? License { get; set; }
        public string? DetailUrl { get; set; }
        public List<ForgeVersionApiData>? Versions { get; set; }
    }

    private class ForgeVersionApiData
    {
        public int Id { get; set; }
        public string? Version { get; set; }
        public string? SptVersionConstraint { get; set; }
        public long Downloads { get; set; }
        public string? PublishedAt { get; set; }
        public string? DownloadUrl { get; set; }
    }

    private static int? ExtractModIdFromForgeUrl(string url)
    {
        if (string.IsNullOrWhiteSpace(url))
            return null;

        try
        {
            var uri = new Uri(url);
            if (!uri.Host.Contains("forge.sp-tarkov.com"))
                return null;

            var segments = uri.AbsolutePath.Split('/', StringSplitOptions.RemoveEmptyEntries);
            
            for (int i = 0; i < segments.Length - 1; i++)
            {
                if (segments[i].Equals("mod", StringComparison.OrdinalIgnoreCase) ||
                    segments[i].Equals("mods", StringComparison.OrdinalIgnoreCase))
                {
                    if (int.TryParse(segments[i + 1], out var modId))
                    {
                        return modId;
                    }
                }
            }
        }
        catch
        {
            // Invalid URL
        }

        return null;
    }

    private async Task ProcessForgeDownload()
    {
        if (_forgeMod == null || string.IsNullOrEmpty(_forgeSelectedVersion))
            return;

        var selectedVersion = _forgeMod.Versions.FirstOrDefault(v => v.Version == _forgeSelectedVersion);
        if (selectedVersion == null || string.IsNullOrEmpty(selectedVersion.DownloadUrl))
        {
            Snackbar.Add("Invalid version selection", Severity.Error);
            return;
        }

        // Switch to downloading state
        _urlsToProcess = new List<string> { selectedVersion.DownloadUrl };
        _downloadResults = new();
        _currentDownloadIndex = 0;
        _addDialogStep = AddDialogStep.Downloading;
        await InvokeAsync(StateHasChanged);

        // Process the download
        _currentDownloadUrl = selectedVersion.DownloadUrl;
        await InvokeAsync(StateHasChanged);

        try
        {
            var result = await ModDownloadService.DownloadAndAnalyzeModAsync(selectedVersion.DownloadUrl);
            
            // Use Forge mod name if available
            if (result.Success)
            {
                result.ModName = _forgeMod.Name;
            }

            _downloadResults.Add(result);

            if (result.Success)
            {
                var installPaths = result.SuggestedInstallPaths.Count > 0 
                    ? result.SuggestedInstallPaths 
                    : result.TopLevelDirectories.Count > 0
                        ? result.TopLevelDirectories.Select(dir => new[] { dir, $"<SPT_ROOT>/{dir}" }).ToList()
                        : new List<string[]> { new[] { "", "<SPT_ROOT>/" } };
                
                var mod = new ModEntry
                {
                    ModName = _forgeMod.Name,
                    DownloadUrl = selectedVersion.DownloadUrl,
                    Optional = _forgeOptional,
                    LastUpdated = DateTime.UtcNow.ToString("o"),
                    InstallPaths = installPaths,
                    Status = ModStatus.Installed // Staged mods represent desired state
                };
                await ConfigService.AddModToStagedAsync(mod);
            }
        }
        catch (Exception ex)
        {
            _downloadResults.Add(new ModDownloadResult
            {
                Url = selectedVersion.DownloadUrl,
                Success = false,
                Error = ex.Message
            });
        }

        _currentDownloadIndex++;
        _addDialogStep = AddDialogStep.Results;
        await InvokeAsync(StateHasChanged);
    }

    private static string GetForgeCategoryStyle(string? colorClass)
    {
        var color = colorClass?.ToLowerInvariant() switch
        {
            "red" => "#ef4444",
            "orange" => "#f97316",
            "yellow" => "#eab308",
            "green" => "#22c55e",
            "teal" => "#14b8a6",
            "cyan" => "#06b6d4",
            "blue" => "#3b82f6",
            "indigo" => "#6366f1",
            "purple" => "#a855f7",
            "pink" => "#ec4899",
            _ => "#6b7280"
        };
        return $"background: {color}; color: #fff;";
    }

    private static string FormatDownloadCount(long count)
    {
        return count switch
        {
            >= 1_000_000 => $"{count / 1_000_000.0:F1}M",
            >= 1_000 => $"{count / 1_000.0:F1}K",
            _ => count.ToString("N0")
        };
    }

    #region Sync Exclusions (manifest opt-out)

    private async Task OnTabChanged(int index)
    {
        _activeTabIndex = index;

        if (index == 1 && !_syncTabInitialized)
        {
            // Initialize default exclusions state
            _useDefaultExclusions = ConfigService.StagedConfig.UseDefaultExclusions;
            _defaultExclusionPatterns = ConfigService.StagedConfig.CustomDefaultExclusions?.ToList() 
                ?? DefaultSyncExclusions.Patterns.ToList();
            _defaultExclusionPatternsText = string.Join("\n", _defaultExclusionPatterns);
            
            await LoadSyncExclusionsTreeAsync();
        }
    }

    private async Task LoadSyncExclusionsTreeAsync()
    {
        _syncExclusionsLoading = true;
        _syncExclusionsError = null;
        await InvokeAsync(StateHasChanged);

        try
        {
            _syncExclusionSet = new HashSet<string>(
                (ConfigService.StagedConfig.SyncExclusions ?? new List<string>())
                    .Select(NormalizeRulePath)
                    .Where(p => !string.IsNullOrWhiteSpace(p)),
                StringComparer.OrdinalIgnoreCase);

            var root = new FileNode { Name = "root", IsDirectory = true, RelativePath = "" };

            AddSyncRoot(ConfigService.BepInExPluginsPath, "BepInEx/plugins", root);
            AddSyncRoot(ConfigService.SptUserModsPath, "SPT/user/mods", root);

            _syncTreeRoot = root;
            _syncTabInitialized = true;
        }
        catch (Exception ex)
        {
            _syncExclusionsError = $"Failed to load exclusions: {ex.Message}";
        }
        finally
        {
            _syncExclusionsLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void AddSyncRoot(string absolutePath, string relativePath, FileNode root)
    {
        if (!Directory.Exists(absolutePath)) return;

        var node = BuildSyncNodeRecursive(absolutePath, NormalizeRulePath(relativePath), relativePath);
        root.Children.Add(node);
    }

    private FileNode BuildSyncNodeRecursive(string fullPath, string relativePath, string? displayName = null)
    {
        var node = new FileNode
        {
            Name = displayName ?? Path.GetFileName(fullPath),
            RelativePath = relativePath,
            IsDirectory = true
        };

        foreach (var dir in Directory.GetDirectories(fullPath))
        {
            var childRel = NormalizeRulePath(Path.Combine(relativePath, Path.GetFileName(dir)));
            node.Children.Add(BuildSyncNodeRecursive(dir, childRel));
        }

        foreach (var file in Directory.GetFiles(fullPath))
        {
            var childRel = NormalizeRulePath(Path.Combine(relativePath, Path.GetFileName(file)));
            node.Children.Add(new FileNode
            {
                Name = Path.GetFileName(file),
                RelativePath = childRel,
                IsDirectory = false
            });
        }

        return node;
    }

    private SyncNodeState GetSyncNodeState(FileNode? node)
    {
        if (node == null) return SyncNodeState.Included;

        var rel = NormalizeRulePath(node.RelativePath);

        if (!node.IsDirectory)
        {
            var isExcluded = IsSyncExcluded(rel);
            return isExcluded ? SyncNodeState.Excluded : SyncNodeState.Included;
        }

        // For directories: derive state from all leaf nodes
        var leaves = GetSyncLeafNodes(node).ToList();
        if (leaves.Count == 0) return SyncNodeState.Included;
        
        var leafStates = leaves.Select(leaf => IsSyncExcluded(NormalizeRulePath(leaf.RelativePath)) ? SyncNodeState.Excluded : SyncNodeState.Included).Distinct().ToList();
        if (leafStates.Count == 1) return leafStates[0];
        return SyncNodeState.Mixed;
    }

    private IEnumerable<FileNode> GetSyncLeafNodes(FileNode? node)
    {
        if (node == null) yield break;

        if (!node.IsDirectory)
        {
            yield return node;
            yield break;
        }

        var children = node.Children;
        if (children == null) yield break;

        foreach (var child in children)
        {
            foreach (var leaf in GetSyncLeafNodes(child))
                yield return leaf;
        }
    }

    private bool IsSyncExcluded(string relativePath)
    {
        var norm = NormalizeRulePath(relativePath);
        return _syncExclusionSet.Any(ex =>
            norm.Equals(ex, StringComparison.OrdinalIgnoreCase) ||
            norm.StartsWith(ex + "/", StringComparison.OrdinalIgnoreCase));
    }

    private async Task OnSyncNodeClick(FileNode node)
    {
        await ToggleSyncNodeAsync(node);
    }

    private void ToggleSyncExpand(FileNode node)
    {
        if (!node.IsDirectory) return;
        
        var path = node.RelativePath;
        if (_syncExpandedDirs.Contains(path))
            _syncExpandedDirs.Remove(path);
        else
            _syncExpandedDirs.Add(path);
        
        StateHasChanged();
    }

    private async Task ToggleSyncNodeAsync(FileNode? node)
    {
        if (node == null) return;

        var current = GetSyncNodeState(node);
        var next = current == SyncNodeState.Excluded ? SyncNodeState.Included : SyncNodeState.Excluded;

        if (node.IsDirectory)
        {
            ApplySyncDirectoryState(node, next);
        }
        else
        {
            ApplySyncFileState(node, next);
        }

        // Immediately save to staged config
        await SaveSyncExclusionsToStagedAsync();
        
        StateHasChanged();
    }

    private void ApplySyncDirectoryState(FileNode? node, SyncNodeState state)
    {
        if (node == null) return;
        var rel = NormalizeRulePath(node.RelativePath);

        // Clear this directory and all its descendants from exclusions
        foreach (var path in EnumerateSyncAllPaths(node).ToList())
            _syncExclusionSet.Remove(path);

        if (state == SyncNodeState.Excluded && !string.IsNullOrEmpty(rel))
        {
            _syncExclusionSet.Add(rel);
        }
        else if (state == SyncNodeState.Included && !string.IsNullOrEmpty(rel))
        {
            // Check if a PROPER ANCESTOR (not self) is excluded - need to lift it
            var ancestorExclusion = _syncExclusionSet
                .FirstOrDefault(ex => rel.StartsWith(ex + "/", StringComparison.OrdinalIgnoreCase));
            
            if (ancestorExclusion != null)
            {
                _syncExclusionSet.Remove(ancestorExclusion);
                var ancestorNode = FindNodeByPath(_syncTreeRoot, ancestorExclusion);
                if (ancestorNode != null)
                {
                    foreach (var leaf in EnumerateSyncLeafPaths(ancestorNode))
                    {
                        var leafNorm = NormalizeRulePath(leaf);
                        if (!leafNorm.StartsWith(rel + "/", StringComparison.OrdinalIgnoreCase) &&
                            !leafNorm.Equals(rel, StringComparison.OrdinalIgnoreCase))
                        {
                            _syncExclusionSet.Add(leafNorm);
                        }
                    }
                }
            }
        }
    }

    private void ApplySyncFileState(FileNode? node, SyncNodeState state)
    {
        if (node == null) return;
        var rel = NormalizeRulePath(node.RelativePath);

        if (state == SyncNodeState.Excluded)
        {
            _syncExclusionSet.Add(rel);
        }
        else
        {
            var ancestorExclusion = _syncExclusionSet
                .FirstOrDefault(ex => rel.StartsWith(ex + "/", StringComparison.OrdinalIgnoreCase));
            
            if (ancestorExclusion != null)
            {
                _syncExclusionSet.Remove(ancestorExclusion);
                var ancestorNode = FindNodeByPath(_syncTreeRoot, ancestorExclusion);
                if (ancestorNode != null)
                {
                    foreach (var leaf in EnumerateSyncLeafPaths(ancestorNode))
                    {
                        var leafNorm = NormalizeRulePath(leaf);
                        if (!leafNorm.Equals(rel, StringComparison.OrdinalIgnoreCase))
                        {
                            _syncExclusionSet.Add(leafNorm);
                        }
                    }
                }
            }
            _syncExclusionSet.Remove(rel);
        }
    }

    private IEnumerable<string> EnumerateSyncAllPaths(FileNode? node)
    {
        if (node == null) yield break;

        if (!string.IsNullOrEmpty(node.RelativePath))
            yield return NormalizeRulePath(node.RelativePath);

        var children = node.Children ?? Enumerable.Empty<FileNode>();
        foreach (var child in children)
            foreach (var p in EnumerateSyncAllPaths(child))
                yield return p;
    }

    private FileNode? FindNodeByPath(FileNode? node, string relativePath)
    {
        if (node == null) return null;
        var norm = NormalizeRulePath(relativePath);
        if (NormalizeRulePath(node.RelativePath).Equals(norm, StringComparison.OrdinalIgnoreCase))
            return node;

        var children = node.Children ?? Enumerable.Empty<FileNode>();
        foreach (var child in children)
        {
            var found = FindNodeByPath(child, relativePath);
            if (found != null) return found;
        }
        return null;
    }

    private IEnumerable<string> EnumerateSyncLeafPaths(FileNode? node)
    {
        if (node == null) yield break;

        if (!node.IsDirectory)
        {
            if (!string.IsNullOrEmpty(node.RelativePath))
                yield return NormalizeRulePath(node.RelativePath);
            yield break;
        }

        var children = node.Children ?? Enumerable.Empty<FileNode>();
        foreach (var child in children)
        {
            foreach (var leaf in EnumerateSyncLeafPaths(child))
                yield return leaf;
        }
    }

    private List<(FileNode Node, int Depth)> GetSyncFlattenedTree()
    {
        var result = new List<(FileNode, int)>();
        if (_syncTreeRoot?.Children == null) return result;

        void Flatten(FileNode node, int depth)
        {
            if (node == null) return;
            result.Add((node, depth));

            // Only recurse into children if this directory is expanded
            if (node.IsDirectory && !_syncExpandedDirs.Contains(node.RelativePath))
                return;

            var children = node.Children;
            if (children != null)
            {
                foreach (var child in children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
                {
                    Flatten(child, depth + 1);
                }
            }
        }

        foreach (var child in _syncTreeRoot.Children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
        {
            Flatten(child, 0);
        }

        return result;
    }

    /// <summary>
    /// Save sync exclusions to staged config (called automatically on each change)
    /// </summary>
    private async Task SaveSyncExclusionsToStagedAsync()
    {
        try
        {
            ConfigService.StagedConfig.SyncExclusions = _syncExclusionSet
                .Select(NormalizeRulePath)
                .Where(p => !string.IsNullOrWhiteSpace(p))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .OrderBy(p => p)
                .ToList();

            await ConfigService.SaveStagedConfigAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save exclusions: {ex.Message}", Severity.Error);
        }
    }
    
    /// <summary>
    /// Toggle use of default exclusion patterns
    /// </summary>
    private async Task OnUseDefaultExclusionsChanged(bool value)
    {
        _useDefaultExclusions = value;
        ConfigService.StagedConfig.UseDefaultExclusions = value;
        await ConfigService.SaveStagedConfigAsync();
        StateHasChanged();
    }
    
    /// <summary>
    /// Handle changes to the default exclusion patterns text
    /// </summary>
    private async Task OnDefaultExclusionPatternsChanged(string text)
    {
        _defaultExclusionPatternsText = text;
        _defaultExclusionPatterns = text
            .Split('\n', StringSplitOptions.RemoveEmptyEntries)
            .Select(p => p.Trim())
            .Where(p => !string.IsNullOrWhiteSpace(p))
            .ToList();
        
        // Save to staged config (null means use built-in defaults)
        ConfigService.StagedConfig.CustomDefaultExclusions = _defaultExclusionPatterns.Count > 0 
            ? _defaultExclusionPatterns 
            : null;
        
        await ConfigService.SaveStagedConfigAsync();
    }
    
    /// <summary>
    /// Reset default exclusions to built-in patterns
    /// </summary>
    private async Task ResetDefaultExclusionsToBuiltIn()
    {
        _defaultExclusionPatterns = DefaultSyncExclusions.Patterns.ToList();
        _defaultExclusionPatternsText = string.Join("\n", _defaultExclusionPatterns);
        ConfigService.StagedConfig.CustomDefaultExclusions = null; // null = use built-in
        await ConfigService.SaveStagedConfigAsync();
        Snackbar.Add("Reset to built-in default patterns.", Severity.Info);
        StateHasChanged();
    }

    #endregion

    // Edit Mod Dialog Methods
    private void EditMod(ModEntry mod)
    {
        // Prevent editing protected mods (like ModGod itself)
        if (mod.IsProtected)
        {
            Snackbar.Add($"'{mod.ModName}' is a built-in mod and cannot be edited.", Severity.Info);
            return;
        }
        
        try
        {
            _editingMod = mod;
            _editModName = mod.ModName ?? string.Empty;
            _editDownloadUrl = mod.DownloadUrl ?? string.Empty;
            _editIsOptional = mod.Optional;
            
            // Safe handling of InstallPaths which may be null from JSON deserialization
            var installPaths = mod.InstallPaths ?? new List<string[]>();
            _editInstallPaths = installPaths
                .Where(p => p != null && p.Length >= 2)
                .Select(p => new InstallPathItem { Source = p[0] ?? string.Empty, Target = p[1] ?? string.Empty })
                .ToList();
            if (_editInstallPaths.Count == 0)
            {
                _editInstallPaths.Add(new InstallPathItem());
            }
            _editDialogVisible = true;

            // Load archive contents for reference
            _archiveContents = null;
            if (!string.IsNullOrEmpty(mod.DownloadUrl) && 
                ConfigService.Staging?.UrlToPath != null &&
                ConfigService.Staging.UrlToPath.TryGetValue(mod.DownloadUrl, out var stagingPath))
            {
                _archiveContents = ModDownloadService.GetExtractedContents(stagingPath);
            }

            // File rule state - safe handling of FileRules
            var rules = mod.FileRules ?? new List<FileCopyRule>();
            _fileRulesIgnore = new HashSet<string>(
                rules.Where(r => r != null && r.State == FileCopyRuleState.Ignore && !string.IsNullOrWhiteSpace(r.Path))
                     .Select(r => NormalizeRulePath(r.Path)),
                StringComparer.OrdinalIgnoreCase);
            _fileRulesExpandedDirs.Clear();
            _fileRulesError = null;
            _fileTreeRoot = null;
            _fileRulesLoading = true;
            
            // Load file tree asynchronously
            _ = LoadFileTreeAsync(mod);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error opening edit dialog: {ex.Message}", Severity.Error);
            _editDialogVisible = false;
        }
    }

    private void AddEditInstallPath()
    {
        _editInstallPaths.Add(new InstallPathItem());
    }

    private void RemoveEditInstallPath(int index)
    {
        if (index >= 0 && index < _editInstallPaths.Count)
        {
            _editInstallPaths.RemoveAt(index);
        }
    }

    private async Task SaveEditMod()
    {
        if (_editingMod == null) return;

        _editingMod.ModName = _editModName;
        _editingMod.Optional = _editIsOptional;
        _editingMod.InstallPaths = _editInstallPaths.Select(p => new[] { p.Source, p.Target }).ToList();
        _editingMod.FileRules = _fileRulesIgnore
            .Select(p => new FileCopyRule { Path = p, State = FileCopyRuleState.Ignore })
            .ToList();
        
        await ConfigService.SaveStagedConfigAsync();
        Snackbar.Add($"Mod '{_editModName}' updated!", Severity.Success);
        
        CloseEditDialog();
    }

    private void CloseEditDialog()
    {
        _editDialogVisible = false;
        _editingMod = null;
        _fileTreeRoot = null;
        _fileRulesIgnore.Clear();
        _archiveContents = null;
    }

    // Reinstall Mod
    private async Task ReinstallMod(ModEntry mod)
    {
        var result = await DialogService.ShowMessageBox(
            "Reinstall Mod",
            $"This will re-download and reinstall '{mod.ModName}'. Continue?",
            yesText: "Reinstall", cancelText: "Cancel");

        if (result == true)
        {
            // Clear staging and re-download
            ConfigService.ClearStagingForUrl(mod.DownloadUrl);
            
            // Trigger download
            var downloadResult = await ModDownloadService.DownloadAndAnalyzeModAsync(mod.DownloadUrl);
            if (downloadResult.Success)
            {
                Snackbar.Add($"Mod '{mod.ModName}' ready for reinstall. Click 'Apply Changes'.", Severity.Success);
            }
            else
            {
                Snackbar.Add($"Failed to download: {downloadResult.Error}", Severity.Error);
            }
            StateHasChanged();
        }
    }

    #region File rules helpers

    private string NormalizeRulePath(string? path)
    {
        if (string.IsNullOrEmpty(path)) return string.Empty;
        return path.Replace("\\", "/").TrimStart('/');
    }

    private async Task LoadFileTreeAsync(ModEntry mod)
    {
        try
        {
            // Safety checks
            var downloadUrl = mod?.DownloadUrl;
            if (string.IsNullOrEmpty(downloadUrl))
            {
                _fileRulesError = "No download URL for this mod.";
                return;
            }

            var staging = ConfigService?.Staging;
            if (staging?.UrlToPath == null || !staging.UrlToPath.TryGetValue(downloadUrl, out var stagingPath))
            {
                _fileRulesError = "Staging not found. Reinstall this mod to view files.";
                return;
            }

            if (string.IsNullOrEmpty(stagingPath))
            {
                _fileRulesError = "Staging path is empty. Reinstall this mod.";
                return;
            }

            var extractedPath = Path.Combine(stagingPath, "extracted");
            
            if (!Directory.Exists(extractedPath))
            {
                _fileRulesError = "Staging extraction not found. Reinstall this mod to view files.";
                return;
            }

            var root = new FileNode { Name = "root", IsDirectory = true, RelativePath = "" };
            var installPaths = _editInstallPaths ?? new List<InstallPathItem>();
            var sptRoot = ConfigService?.SptRoot ?? string.Empty;
            var filesFound = 0;
            
            foreach (var install in installPaths
                .Where(p => p != null && !string.IsNullOrWhiteSpace(p.Source) && !string.IsNullOrWhiteSpace(p.Target))
                .DistinctBy(p => p.Source, StringComparer.OrdinalIgnoreCase))
            {
                var sourcePath = Path.Combine(extractedPath, install.Source);
                // Replace <SPT_ROOT> placeholder with actual path
                var targetBasePath = install.Target
                    .Replace("<SPT_ROOT>", sptRoot)
                    .Replace("/", Path.DirectorySeparatorChar.ToString());
                
                if (Directory.Exists(sourcePath))
                {
                    // Build tree only for files that would overwrite existing files
                    var node = BuildNodeRecursiveWithOverwriteCheck(sourcePath, NormalizeRulePath(install.Source), targetBasePath, ref filesFound);
                    if (node != null && (node.Children?.Count > 0 || !node.IsDirectory))
                    {
                        MergeNode(root, node);
                    }
                }
                else if (File.Exists(sourcePath))
                {
                    // Single file - check if target exists
                    var targetFile = Path.Combine(targetBasePath);
                    if (File.Exists(targetFile))
                    {
                        AddFileNode(root, NormalizeRulePath(install.Source));
                        filesFound++;
                    }
                }
            }

            _fileTreeRoot = root;
            
            if (filesFound == 0)
            {
                _fileRulesError = "No existing files would be overwritten by this mod. All files are new.";
            }
            else
            {
                _fileRulesError = null;
            }
        }
        catch (Exception ex)
        {
            _fileRulesError = $"Failed to load file tree: {ex.Message}";
        }
        finally
        {
            _fileRulesLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private FileNode? BuildNodeRecursiveWithOverwriteCheck(string fullSourcePath, string relativePath, string fullTargetPath, ref int filesFound)
    {
        var node = new FileNode
        {
            Name = Path.GetFileName(fullSourcePath),
            RelativePath = relativePath,
            IsDirectory = true
        };

        foreach (var dir in Directory.GetDirectories(fullSourcePath))
        {
            var dirName = Path.GetFileName(dir);
            var childRel = NormalizeRulePath(Path.Combine(relativePath, dirName));
            var childTargetPath = Path.Combine(fullTargetPath, dirName);
            
            var childNode = BuildNodeRecursiveWithOverwriteCheck(dir, childRel, childTargetPath, ref filesFound);
            if (childNode != null && (childNode.Children?.Count > 0 || !childNode.IsDirectory))
            {
                node.Children.Add(childNode);
            }
        }

        foreach (var file in Directory.GetFiles(fullSourcePath))
        {
            var fileName = Path.GetFileName(file);
            var childRel = NormalizeRulePath(Path.Combine(relativePath, fileName));
            var targetFilePath = Path.Combine(fullTargetPath, fileName);
            
            // Only include if the target file already exists (would be overwritten)
            if (File.Exists(targetFilePath))
            {
                node.Children.Add(new FileNode
                {
                    Name = fileName,
                    RelativePath = childRel,
                    IsDirectory = false
                });
                filesFound++;
            }
        }

        // Return null if this directory has no children (nothing to overwrite)
        return node.Children.Count > 0 ? node : null;
    }

    private FileNode BuildNodeRecursive(string fullPath, string relativePath)
    {
        var node = new FileNode
        {
            Name = Path.GetFileName(fullPath),
            RelativePath = relativePath,
            IsDirectory = true
        };

        foreach (var dir in Directory.GetDirectories(fullPath))
        {
            var childRel = NormalizeRulePath(Path.Combine(relativePath, Path.GetFileName(dir)));
            node.Children.Add(BuildNodeRecursive(dir, childRel));
        }

        foreach (var file in Directory.GetFiles(fullPath))
        {
            var childRel = NormalizeRulePath(Path.Combine(relativePath, Path.GetFileName(file)));
            node.Children.Add(new FileNode
            {
                Name = Path.GetFileName(file),
                RelativePath = childRel,
                IsDirectory = false
            });
        }

        return node;
    }

    private void MergeNode(FileNode parent, FileNode child)
    {
        var existing = parent.Children.FirstOrDefault(c =>
            c.IsDirectory &&
            c.Name.Equals(child.Name, StringComparison.OrdinalIgnoreCase) &&
            c.RelativePath.Equals(child.RelativePath, StringComparison.OrdinalIgnoreCase));

        if (existing == null)
        {
            parent.Children.Add(child);
            return;
        }

        foreach (var grand in child.Children)
        {
            if (grand.IsDirectory)
            {
                MergeNode(existing, grand);
            }
            else if (!existing.Children.Any(c => !c.IsDirectory && c.RelativePath.Equals(grand.RelativePath, StringComparison.OrdinalIgnoreCase)))
            {
                existing.Children.Add(grand);
            }
        }
    }

    private void AddFileNode(FileNode root, string relativePath)
    {
        var parts = relativePath.Split('/', StringSplitOptions.RemoveEmptyEntries);
        var current = root;
        var accumulated = "";
        for (int i = 0; i < parts.Length; i++)
        {
            accumulated = string.IsNullOrEmpty(accumulated) ? parts[i] : $"{accumulated}/{parts[i]}";
            var part = parts[i];
            var isLast = i == parts.Length - 1;
            if (isLast)
            {
                if (!current.Children.Any(c => !c.IsDirectory && c.Name.Equals(part, StringComparison.OrdinalIgnoreCase)))
                {
                    current.Children.Add(new FileNode
                    {
                        Name = part,
                        RelativePath = accumulated,
                        IsDirectory = false
                    });
                }
            }
            else
            {
                var dir = current.Children.FirstOrDefault(c => c.IsDirectory && c.Name.Equals(part, StringComparison.OrdinalIgnoreCase));
                if (dir == null)
                {
                    dir = new FileNode { Name = part, RelativePath = accumulated, IsDirectory = true };
                    current.Children.Add(dir);
                }
                current = dir;
            }
        }
    }

    private FileRuleState GetNodeState(FileNode? node)
    {
        if (node == null) return FileRuleState.Overwrite;
        
        if (!node.IsDirectory)
        {
            return IsPathIgnored(node.RelativePath) ? FileRuleState.Ignore : FileRuleState.Overwrite;
        }

        var leafStates = GetLeafNodes(node).Select(GetNodeState).Distinct().ToList();
        if (leafStates.Count == 0) return FileRuleState.Overwrite;
        if (leafStates.Count == 1) return leafStates[0];
        return FileRuleState.Mixed;
    }

    private IEnumerable<FileNode> GetLeafNodes(FileNode? node)
    {
        if (node == null) yield break;
        
        if (!node.IsDirectory)
        {
            yield return node;
            yield break;
        }

        var children = node.Children;
        if (children == null) yield break;
        
        foreach (var child in children)
        {
            foreach (var leaf in GetLeafNodes(child))
                yield return leaf;
        }
    }

    private bool IsPathIgnored(string relativePath)
    {
        var norm = NormalizeRulePath(relativePath);
        return _fileRulesIgnore.Any(r =>
            norm.Equals(r, StringComparison.OrdinalIgnoreCase) ||
            norm.StartsWith(r + "/", StringComparison.OrdinalIgnoreCase));
    }

    private void ToggleFileRulesExpand(FileNode node)
    {
        if (!node.IsDirectory) return;
        
        var path = node.RelativePath;
        if (_fileRulesExpandedDirs.Contains(path))
            _fileRulesExpandedDirs.Remove(path);
        else
            _fileRulesExpandedDirs.Add(path);
        
        StateHasChanged();
    }

    private void ToggleNode(FileNode? node)
    {
        if (node == null) return;
        
        var current = GetNodeState(node);
        var next = current == FileRuleState.Ignore ? FileRuleState.Overwrite : FileRuleState.Ignore;

        if (node.IsDirectory)
        {
            ApplyDirectoryState(node, next);
        }
        else
        {
            ApplyFileState(node, next);
        }

        StateHasChanged();
    }

    private void ApplyFileState(FileNode? node, FileRuleState state)
    {
        if (node == null) return;
        var rel = NormalizeRulePath(node.RelativePath);

        if (state == FileRuleState.Ignore)
        {
            _fileRulesIgnore.Add(rel);
        }
        else
        {
            // Check if ignored via a parent directory
            var ancestorIgnore = _fileRulesIgnore
                .FirstOrDefault(r => rel.StartsWith(r + "/", StringComparison.OrdinalIgnoreCase));
            
            if (ancestorIgnore != null)
            {
                // Lift ancestor and add ignores for all sibling leaves
                _fileRulesIgnore.Remove(ancestorIgnore);
                var ancestorNode = FindFileRulesNodeByPath(_fileTreeRoot, ancestorIgnore);
                if (ancestorNode != null)
                {
                    foreach (var leaf in GetLeafNodes(ancestorNode))
                    {
                        var leafRel = NormalizeRulePath(leaf.RelativePath);
                        if (!leafRel.Equals(rel, StringComparison.OrdinalIgnoreCase))
                        {
                            _fileRulesIgnore.Add(leafRel);
                        }
                    }
                }
            }
            _fileRulesIgnore.Remove(rel);
        }
    }

    private FileNode? FindFileRulesNodeByPath(FileNode? node, string relativePath)
    {
        if (node == null) return null;
        var norm = NormalizeRulePath(relativePath);
        if (NormalizeRulePath(node.RelativePath).Equals(norm, StringComparison.OrdinalIgnoreCase))
            return node;

        foreach (var child in node.Children ?? Enumerable.Empty<FileNode>())
        {
            var found = FindFileRulesNodeByPath(child, relativePath);
            if (found != null) return found;
        }
        return null;
    }

    private void ApplyDirectoryState(FileNode? node, FileRuleState state)
    {
        if (node == null) return;
        
        // Clear this directory and all descendants from ignores
        foreach (var path in EnumeratePaths(node).ToList())
        {
            _fileRulesIgnore.Remove(path);
        }

        if (state == FileRuleState.Ignore && !string.IsNullOrEmpty(node.RelativePath))
        {
            _fileRulesIgnore.Add(NormalizeRulePath(node.RelativePath));
        }
        else if (state == FileRuleState.Overwrite && !string.IsNullOrEmpty(node.RelativePath))
        {
            // Check if ignored via a parent directory - need to lift it
            var rel = NormalizeRulePath(node.RelativePath);
            var ancestorIgnore = _fileRulesIgnore
                .FirstOrDefault(r => rel.StartsWith(r + "/", StringComparison.OrdinalIgnoreCase));
            
            if (ancestorIgnore != null)
            {
                _fileRulesIgnore.Remove(ancestorIgnore);
                var ancestorNode = FindFileRulesNodeByPath(_fileTreeRoot, ancestorIgnore);
                if (ancestorNode != null)
                {
                    foreach (var leaf in GetLeafNodes(ancestorNode))
                    {
                        var leafRel = NormalizeRulePath(leaf.RelativePath);
                        // Don't ignore leaves under the directory being set to Overwrite
                        if (!leafRel.StartsWith(rel + "/", StringComparison.OrdinalIgnoreCase) &&
                            !leafRel.Equals(rel, StringComparison.OrdinalIgnoreCase))
                        {
                            _fileRulesIgnore.Add(leafRel);
                        }
                    }
                }
            }
        }
    }

    private IEnumerable<string> EnumeratePaths(FileNode? node)
    {
        if (node == null) yield break;
        
        if (!string.IsNullOrEmpty(node.RelativePath))
            yield return NormalizeRulePath(node.RelativePath);

        var children = node.Children;
        if (children == null) yield break;
        
        foreach (var child in children)
        {
            foreach (var p in EnumeratePaths(child))
                yield return p;
        }
    }

    private List<(FileNode Node, int Depth)> GetFlattenedTree()
    {
        var result = new List<(FileNode, int)>();
        if (_fileTreeRoot?.Children == null) return result;
        
        void Flatten(FileNode node, int depth)
        {
            if (node == null) return;
            result.Add((node, depth));
            
            // Only recurse into children if this directory is expanded
            if (node.IsDirectory && !_fileRulesExpandedDirs.Contains(node.RelativePath))
                return;
            
            var children = node.Children;
            if (children != null)
            {
                foreach (var child in children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
                {
                    Flatten(child, depth + 1);
                }
            }
        }
        
        foreach (var child in _fileTreeRoot.Children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
        {
            Flatten(child, 0);
        }
        
        return result;
    }

    #endregion

    #region Uninstall helpers

    private string NormalizeDeletionPath(string? path)
    {
        if (string.IsNullOrWhiteSpace(path)) return string.Empty;
        var cleaned = path.Replace("\\", "/").Replace("<SPT_ROOT>", "", StringComparison.OrdinalIgnoreCase);
        return cleaned.TrimStart('/');
    }

    private string ToPlaceholderPath(string relativePath)
    {
        var normalized = NormalizeDeletionPath(relativePath);
        return string.IsNullOrEmpty(normalized) ? string.Empty : $"<SPT_ROOT>/{normalized}";
    }

    private FileNode? BuildUninstallNodeRecursive(string fullPath, string relativePath)
    {
        if (!Directory.Exists(fullPath))
            return null;

        var node = new FileNode
        {
            Name = Path.GetFileName(fullPath),
            RelativePath = NormalizeDeletionPath(relativePath),
            IsDirectory = true
        };

        foreach (var dir in Directory.GetDirectories(fullPath))
        {
            var name = Path.GetFileName(dir);
            var childRel = NormalizeDeletionPath(Path.Combine(relativePath, name));
            var child = BuildUninstallNodeRecursive(dir, childRel);
            if (child != null)
            {
                node.Children.Add(child);
            }
        }

        foreach (var file in Directory.GetFiles(fullPath))
        {
            var name = Path.GetFileName(file);
            var childRel = NormalizeDeletionPath(Path.Combine(relativePath, name));
            node.Children.Add(new FileNode
            {
                Name = name,
                RelativePath = childRel,
                IsDirectory = false
            });
        }

        return node;
    }

    private IEnumerable<FileNode> GetUninstallLeafNodes(FileNode? node)
    {
        if (node == null) yield break;

        var children = node.Children;
        if (!node.IsDirectory || children == null || children.Count == 0)
        {
            yield return node;
            yield break;
        }

        foreach (var child in children)
        {
            foreach (var leaf in GetUninstallLeafNodes(child))
                yield return leaf;
        }
    }

    private DeleteNodeState GetUninstallNodeState(FileNode node)
    {
        if (!node.IsDirectory || node.Children == null || node.Children.Count == 0)
        {
            return _uninstallCheckedPaths.Contains(node.RelativePath)
                ? DeleteNodeState.Delete
                : DeleteNodeState.Keep;
        }

        var leafStates = GetUninstallLeafNodes(node).Select(GetUninstallNodeState).Distinct().ToList();
        if (leafStates.Count == 0) return DeleteNodeState.Keep;
        if (leafStates.Count == 1) return leafStates[0];
        return DeleteNodeState.Mixed;
    }

    private void SetUninstallState(FileNode node, bool delete)
    {
        foreach (var leaf in GetUninstallLeafNodes(node))
        {
            if (delete)
            {
                _uninstallCheckedPaths.Add(leaf.RelativePath);
            }
            else
            {
                _uninstallCheckedPaths.Remove(leaf.RelativePath);
            }
        }
    }

    private void ToggleUninstallNode(FileNode node)
    {
        var makeDelete = GetUninstallNodeState(node) != DeleteNodeState.Delete;
        SetUninstallState(node, makeDelete);
    }

    private void ToggleUninstallExpand(FileNode node)
    {
        if (node == null || !node.IsDirectory) return;

        if (_uninstallExpandedDirs.Contains(node.RelativePath))
            _uninstallExpandedDirs.Remove(node.RelativePath);
        else
            _uninstallExpandedDirs.Add(node.RelativePath);
    }

    private void SetInitialUninstallExpansion(FileNode root)
    {
        void Walk(FileNode node)
        {
            if (node.IsDirectory)
            {
                var state = GetUninstallNodeState(node);
                if (state != DeleteNodeState.Keep && !string.IsNullOrEmpty(node.RelativePath))
                {
                    _uninstallExpandedDirs.Add(node.RelativePath);
                }
            }

            foreach (var child in node.Children ?? Enumerable.Empty<FileNode>())
            {
                Walk(child);
            }
        }

        Walk(root);
    }

    private FileNode? FindUninstallNodeByPath(FileNode? node, string relativePath)
    {
        if (node == null) return null;
        var norm = NormalizeDeletionPath(relativePath);
        if (NormalizeDeletionPath(node.RelativePath).Equals(norm, StringComparison.OrdinalIgnoreCase))
            return node;

        foreach (var child in node.Children ?? Enumerable.Empty<FileNode>())
        {
            var found = FindUninstallNodeByPath(child, relativePath);
            if (found != null) return found;
        }
        return null;
    }

    private List<(FileNode Node, int Depth)> GetUninstallFlattenedTree()
    {
        var result = new List<(FileNode, int)>();
        if (_uninstallTreeRoot?.Children == null) return result;

        void Flatten(FileNode node, int depth)
        {
            if (node == null) return;
            result.Add((node, depth));

            if (node.IsDirectory && !_uninstallExpandedDirs.Contains(node.RelativePath))
            {
                return;
            }

            var children = node.Children;
            if (children != null)
            {
                foreach (var child in children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
                {
                    Flatten(child, depth + 1);
                }
            }
        }

        foreach (var child in _uninstallTreeRoot.Children.OrderByDescending(c => c.IsDirectory).ThenBy(c => c.Name))
        {
            Flatten(child, 0);
        }

        return result;
    }

    private async Task LoadUninstallTreeAsync(ModEntry mod)
    {
        try
        {
            _uninstallTreeLoading = true;
            _uninstallTreeError = null;
            _uninstallTreeRoot = null;
            _uninstallCheckedPaths.Clear();
            _uninstallExpandedDirs.Clear();

            var existingSelection = ConfigService.GetRemovalSelection(mod.DownloadUrl) ?? new List<string>();
            var installedFiles = mod.InstalledFiles ?? new List<string>();
            var prechecked = (existingSelection.Count > 0 ? existingSelection : installedFiles)
                .Select(NormalizeDeletionPath)
                .Where(p => !string.IsNullOrWhiteSpace(p))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();
            _uninstallNoAutoPaths = prechecked.Count == 0;

            var root = new FileNode { Name = "root", IsDirectory = true, RelativePath = "" };

            var sptRoot = ConfigService.SptRoot;
            var bepPlugins = Path.Combine(sptRoot, "BepInEx", "plugins");
            var sptMods = Path.Combine(sptRoot, "SPT", "user", "mods");

            void TryAddDirectory(string fullPath, string relativeBase)
            {
                if (Directory.Exists(fullPath))
                {
                    var node = BuildUninstallNodeRecursive(fullPath, relativeBase);
                    if (node != null)
                    {
                        root.Children.Add(node);
                    }
                }
            }

            TryAddDirectory(bepPlugins, "BepInEx/plugins");
            TryAddDirectory(sptMods, "SPT/user/mods");

            // Apply prechecked selections
            foreach (var rel in prechecked)
            {
                var node = FindUninstallNodeByPath(root, rel);
                if (node != null)
                {
                    SetUninstallState(node, true);
                }
            }

            _uninstallExpandedDirs.Clear();
            SetInitialUninstallExpansion(root);

            if (root.Children.Count == 0)
            {
                _uninstallTreeError = "No paths detected. This will remove the mod from your list only.";
            }
            else
            {
                _uninstallTreeRoot = root;
            }
        }
        catch (Exception ex)
        {
            _uninstallTreeError = $"Failed to load delete paths: {ex.Message}";
        }
        finally
        {
            _uninstallTreeLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OpenUninstallDialog(ModEntry mod)
    {
        _uninstallMod = mod;
        _uninstallDialogVisible = true;
        await LoadUninstallTreeAsync(mod);
    }

    private void CloseUninstallDialog()
    {
        _uninstallDialogVisible = false;
        _uninstallMod = null;
        _uninstallTreeRoot = null;
        _uninstallTreeError = null;
        _uninstallTreeLoading = false;
        _uninstallCheckedPaths.Clear();
        _uninstallExpandedDirs.Clear();
        _uninstallNoAutoPaths = false;
    }

    private async Task ConfirmUninstallSelection()
    {
        if (_uninstallMod == null) return;

        var selectedPaths = _uninstallCheckedPaths
            .Select(ToPlaceholderPath)
            .Where(p => !string.IsNullOrWhiteSpace(p))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();

        ConfigService.SetRemovalSelection(_uninstallMod.DownloadUrl, selectedPaths);

        await ConfigService.RemoveModFromStagedAsync(_uninstallMod.DownloadUrl);
        Snackbar.Add($"Mod '{_uninstallMod.ModName}' will be removed. Click 'Apply Changes' to uninstall.", Severity.Warning);

        CloseUninstallDialog();
        StateHasChanged();
    }

    #endregion

    // Delete Mod
    private async Task DeleteMod(ModEntry mod)
    {
        // Prevent deletion of protected mods (like ModGod itself)
        if (mod.IsProtected)
        {
            Snackbar.Add($"'{mod.ModName}' is a protected mod and cannot be removed.", Severity.Warning);
            return;
        }
        
        // With staged config, we always remove from staged config
        // The difference is just in the messaging
        var isPending = IsModPendingInstall(mod);
        var isRemoval = IsModPendingRemoval(mod);
        
        if (isPending)
        {
            // Not yet installed - just remove from staged config
            var result = await DialogService.ShowMessageBox(
                "Remove Mod",
                $"Remove '{mod.ModName}' from the mod list? (It hasn't been installed yet)",
                yesText: "Remove", cancelText: "Cancel");

            if (result == true)
            {
                await ConfigService.RemoveModFromStagedAsync(mod.DownloadUrl);
                Snackbar.Add($"Mod '{mod.ModName}' removed.", Severity.Warning);
                StateHasChanged();
            }
        }
        else if (isRemoval)
        {
            await OpenUninstallDialog(mod);
        }
        else
        {
            await OpenUninstallDialog(mod);
        }
    }

    // Search and Filter Methods
    private List<ModEntry> GetFilteredMods()
    {
        // Combine staged mods (working copy) with pending removal mods (from live config but removed in staged)
        var stagedMods = ConfigService.StagedConfig.ModList;
        var removalSet = GetPendingRemovalUrlSet();
        var removalMods = ConfigService.Config.ModList
            .Where(m => removalSet.Contains(m.DownloadUrl))
            .ToList();

        var allMods = stagedMods.Concat(removalMods)
            .GroupBy(m => m.DownloadUrl)
            .Select(g => g.First())
            .AsEnumerable();
        
        // Apply status filter
        if (_activeStatusFilter != null)
        {
            allMods = _activeStatusFilter switch
            {
                "Installed" => allMods.Where(m => !IsModPendingInstall(m) && !IsModPendingRemoval(m)),
                "Pending" => allMods.Where(m => IsModPendingInstall(m)),
                "PendingRemoval" => allMods.Where(m => IsModPendingRemoval(m)),
                "Required" => allMods.Where(m => !m.Optional),
                "Optional" => allMods.Where(m => m.Optional),
                _ => allMods
            };
        }
        
        // Apply search filter (case insensitive)
        if (!string.IsNullOrWhiteSpace(_searchQuery))
        {
            var query = _searchQuery.Trim();
            allMods = allMods.Where(m => 
                m.ModName.Contains(query, StringComparison.OrdinalIgnoreCase) ||
                m.DownloadUrl.Contains(query, StringComparison.OrdinalIgnoreCase));
        }
        
        return allMods.ToList();
    }
    
    private void ToggleStatusFilter(string? filter)
    {
        // If clicking the same filter, clear it; otherwise set it
        _activeStatusFilter = _activeStatusFilter == filter ? null : filter;
    }
    
    private void ClearFilters()
    {
        _searchQuery = "";
        _activeStatusFilter = null;
    }
    
    private string GetStatsCardStyle(string? filter)
    {
        var isActive = _activeStatusFilter == filter;
        var baseStyle = "background: var(--card-bg); border-radius: 8px; cursor: pointer; transition: all 0.2s ease; min-width: 140px;";
        
        if (isActive)
        {
            // Active state - highlighted border based on filter type
            var borderColor = filter switch
            {
                "Installed" => "var(--accent-green)",
                "Pending" => "var(--accent-orange)",
                "PendingRemoval" => "var(--accent-red)",
                "Required" => "var(--accent-red)",
                "Optional" => "var(--accent-green)",
                _ => "var(--accent-cyan)" // Total
            };
            return $"{baseStyle} border: 2px solid {borderColor}; box-shadow: 0 0 12px {borderColor}40;";
        }
        else
        {
            return $"{baseStyle} border: 1px solid var(--border-color);";
        }
    }

    // Utility Methods
    private string TruncateUrl(string url)
    {
        if (url.Length <= 50) return url;
        return url.Substring(0, 25) + "..." + url.Substring(url.Length - 22);
    }

    /// <summary>
    /// Check if a mod is pending install (in staged but not in live config)
    /// </summary>
    private bool IsModPendingInstall(ModEntry mod)
    {
        return !ConfigService.Config.ModList.Any(m => m.DownloadUrl == mod.DownloadUrl);
    }
    
    /// <summary>
    /// Get set of URLs pending removal (present in live but removed from staged)
    /// </summary>
    private HashSet<string> GetPendingRemovalUrlSet()
    {
        return ConfigService.CalculateStagedChanges().ModsToRemove
            .Select(m => m.DownloadUrl)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);
    }
    
    /// <summary>
    /// Get count of mods that are already installed (in both staged and live)
    /// </summary>
    private int GetInstalledModCount()
    {
        var liveUrls = ConfigService.Config.ModList.Select(m => m.DownloadUrl).ToHashSet();
        return ConfigService.StagedConfig.ModList.Count(m => liveUrls.Contains(m.DownloadUrl));
    }
    
    /// <summary>
    /// Get count of mods pending install (in staged but not in live)
    /// </summary>
    private int GetPendingModCount()
    {
        var liveUrls = ConfigService.Config.ModList.Select(m => m.DownloadUrl).ToHashSet();
        return ConfigService.StagedConfig.ModList.Count(m => !liveUrls.Contains(m.DownloadUrl));
    }

    /// <summary>
    /// Get count of mods pending removal (in live but removed from staged)
    /// </summary>
    private int GetPendingRemovalCount()
    {
        return GetPendingRemovalUrlSet().Count;
    }

    /// <summary>
    /// Check if a mod needs configuration (pending install but no install paths)
    /// </summary>
    private bool ModNeedsConfiguration(ModEntry mod)
    {
        return IsModPendingInstall(mod) && 
            (mod.InstallPaths.Count == 0 || 
             mod.InstallPaths.All(p => p == null || p.Length < 2 || string.IsNullOrWhiteSpace(p[0])));
    }

    private bool AnyModsNeedConfiguration()
    {
        return ConfigService.StagedConfig.ModList.Any(ModNeedsConfiguration);
    }

    private string FormatTimestamp(string timestamp)
    {
        if (DateTime.TryParse(timestamp, out var dt))
        {
            return dt.ToString("MMM dd, yyyy HH:mm");
        }
        return "Never";
    }

    private string GetModCardStyle(ModEntry mod)
    {
        var baseStyle = "background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; height: 100%;";
        
        if (ModNeedsConfiguration(mod))
        {
            return baseStyle + " border-left: 4px solid var(--accent-red);";
        }
        
        // Check staged status instead of mod.Status
        if (IsModPendingInstall(mod))
        {
            return baseStyle + " border-left: 4px solid var(--accent-orange);";
        }
        
        // Check if mod is pending removal (in live but not in staged)
        if (IsModPendingRemoval(mod))
        {
            return baseStyle + " border-left: 4px solid var(--accent-red); opacity: 0.7;";
        }
        
        return baseStyle;
    }
    
    /// <summary>
    /// Check if a mod is pending removal (in live config but not in staged - staged from a remove action)
    /// Note: We show mods from staged config in UI, but we can still track this for styling
    /// </summary>
    private bool IsModPendingRemoval(ModEntry mod)
    {
        var removalSet = GetPendingRemovalUrlSet();
        return removalSet.Contains(mod.DownloadUrl);
    }

    private string GetStatusChipStyleForMod(ModEntry mod)
    {
        if (IsModPendingInstall(mod))
        {
            return "background: var(--accent-orange); color: #000;";
        }
        if (IsModPendingRemoval(mod))
        {
            return "background: var(--accent-red); color: #fff;";
        }
        return "background: var(--accent-green); color: #000;";
    }

    private string GetStatusTextForMod(ModEntry mod)
    {
        if (IsModPendingInstall(mod))
        {
            return "Pending Install";
        }
        if (IsModPendingRemoval(mod))
        {
            return "Pending Uninstall";
        }
        return "Installed";
    }

    private async Task UndoRemoval(ModEntry mod)
    {
        try
        {
            var liveMod = ConfigService.Config.ModList.FirstOrDefault(m => m.DownloadUrl == mod.DownloadUrl);
            if (liveMod == null)
            {
                Snackbar.Add("Unable to undo removal: mod not found in live config.", Severity.Warning);
                return;
            }

            // Deep clone to avoid mutating live reference
            var cloneJson = JsonSerializer.Serialize(liveMod);
            var clone = JsonSerializer.Deserialize<ModEntry>(cloneJson);
            if (clone == null)
            {
                Snackbar.Add("Unable to undo removal: serialization failed.", Severity.Error);
                return;
            }

            await ConfigService.AddModToStagedAsync(clone);
            // Remove from removalSelections in staged config
            ConfigService.StagedConfig.RemovalSelections.Remove(mod.DownloadUrl);
            await ConfigService.SaveStagedConfigAsync();
            Snackbar.Add($"Removal undone for '{clone.ModName}'!", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to undo removal: {ex.Message}", Severity.Error);
        }
    }
    
    // Legacy helpers for backwards compatibility
    private string GetStatusChipStyle(ModStatus status)
    {
        return status switch
        {
            ModStatus.Installed => "background: var(--accent-green); color: #000;",
            ModStatus.Pending => "background: var(--accent-orange); color: #000;",
            ModStatus.PendingRemoval => "background: var(--accent-red); color: #fff;",
            _ => "background: var(--text-secondary); color: #000;"
        };
    }

    private string GetStatusText(ModStatus status)
    {
        return status switch
        {
            ModStatus.Installed => "Installed",
            ModStatus.Pending => "Pending Install",
            ModStatus.PendingRemoval => "Pending Removal",
            _ => "Unknown"
        };
    }

    private (int OverwriteCount, int SkippedCount) GetOverwriteStatsForMod(ModEntry mod)
    {
        try
        {
            var downloadUrl = mod?.DownloadUrl;
            if (string.IsNullOrEmpty(downloadUrl)) return (0, 0);

            var staging = ConfigService?.Staging;
            if (staging?.UrlToPath == null || !staging.UrlToPath.TryGetValue(downloadUrl, out var stagingPath))
                return (0, 0);

            if (string.IsNullOrEmpty(stagingPath)) return (0, 0);

            var extractedPath = Path.Combine(stagingPath, "extracted");
            if (!Directory.Exists(extractedPath)) return (0, 0);

            var installPaths = mod?.InstallPaths ?? new List<string[]>();
            var sptRoot = ConfigService?.SptRoot ?? string.Empty;
            
            // Build set of ignored paths from FileRules
            var ignoredPaths = new HashSet<string>(
                (mod?.FileRules ?? new List<FileCopyRule>())
                    .Where(r => r?.State == FileCopyRuleState.Ignore && !string.IsNullOrWhiteSpace(r.Path))
                    .Select(r => NormalizeRulePath(r.Path)),
                StringComparer.OrdinalIgnoreCase);
            
            var overwriteCount = 0;
            var skippedCount = 0;

            foreach (var pathPair in installPaths.Where(p => p != null && p.Length >= 2))
            {
                var source = pathPair[0];
                var target = pathPair[1];
                if (string.IsNullOrWhiteSpace(source) || string.IsNullOrWhiteSpace(target)) continue;

                var sourcePath = Path.Combine(extractedPath, source);
                var targetBasePath = target
                    .Replace("<SPT_ROOT>", sptRoot)
                    .Replace("/", Path.DirectorySeparatorChar.ToString());

                if (Directory.Exists(sourcePath))
                {
                    var (ow, sk) = CountOverwriteFilesWithRules(sourcePath, targetBasePath, NormalizeRulePath(source), ignoredPaths);
                    overwriteCount += ow;
                    skippedCount += sk;
                }
                else if (File.Exists(sourcePath) && File.Exists(targetBasePath))
                {
                    var relPath = NormalizeRulePath(source);
                    if (IsPathInIgnoreSet(relPath, ignoredPaths))
                        skippedCount++;
                    else
                        overwriteCount++;
                }
            }

            return (overwriteCount, skippedCount);
        }
        catch
        {
            return (0, 0);
        }
    }

    private (int OverwriteCount, int SkippedCount) CountOverwriteFilesWithRules(string sourceDir, string targetDir, string relativeBase, HashSet<string> ignoredPaths)
    {
        var overwriteCount = 0;
        var skippedCount = 0;
        
        foreach (var file in Directory.GetFiles(sourceDir))
        {
            var targetFile = Path.Combine(targetDir, Path.GetFileName(file));
            if (File.Exists(targetFile))
            {
                var relPath = NormalizeRulePath(Path.Combine(relativeBase, Path.GetFileName(file)));
                if (IsPathInIgnoreSet(relPath, ignoredPaths))
                    skippedCount++;
                else
                    overwriteCount++;
            }
        }

        foreach (var dir in Directory.GetDirectories(sourceDir))
        {
            var dirName = Path.GetFileName(dir);
            var targetSubDir = Path.Combine(targetDir, dirName);
            var childRelBase = NormalizeRulePath(Path.Combine(relativeBase, dirName));
            var (ow, sk) = CountOverwriteFilesWithRules(dir, targetSubDir, childRelBase, ignoredPaths);
            overwriteCount += ow;
            skippedCount += sk;
        }

        return (overwriteCount, skippedCount);
    }

    private bool IsPathInIgnoreSet(string path, HashSet<string> ignoredPaths)
    {
        var norm = NormalizeRulePath(path);
        return ignoredPaths.Any(r =>
            norm.Equals(r, StringComparison.OrdinalIgnoreCase) ||
            norm.StartsWith(r + "/", StringComparison.OrdinalIgnoreCase));
    }
}
